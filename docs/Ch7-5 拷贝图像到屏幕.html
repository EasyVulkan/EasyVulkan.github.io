<!DOCTYPE html>
<html class="writer-html5" lang="zh" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ch7-5 拷贝图像到屏幕 &mdash; EasyVulkan</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="prev" title="Ch7-4 初识uniform缓冲区" href="Ch7-4%20%E5%88%9D%E8%AF%86uniform%E7%BC%93%E5%86%B2%E5%8C%BA.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> EasyVulkan
            <img src="_static/logo1.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">第一章 初始化</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch1-0%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html">Ch1-0 准备工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-1%20%E5%88%9B%E5%BB%BAGLFW%E7%AA%97%E5%8F%A3.html">Ch1-1 创建GLFW窗口</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B.html">Ch1-2 初始化流程</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-3%20%E5%88%9B%E5%BB%BAVK%E5%AE%9E%E4%BE%8B%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87.html">Ch1-3 创建VK实例与逻辑设备</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-4%20%E5%88%9B%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE.html">Ch1-4 创建交换链</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第二章 绘制一个三角形</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch2-0%20%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86%E5%8F%8A%E4%B8%80%E4%BA%9B%E8%BE%85%E5%8A%A9%E7%B1%BB.html">Ch2-0 代码整理及一些辅助类</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch2-1%20Rendering%20Loop.html">Ch2-1 Rendering Loop</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch2-2%20%E5%88%9B%E5%BB%BA%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93%E5%92%8C%E5%B8%A7%E7%BC%93%E5%86%B2.html">Ch2-2 创建渲染通道和帧缓冲</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch2-3%20%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%BA%BF%E5%B9%B6%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2.html">Ch2-3 创建管线并绘制三角形</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第三章 纵观Vulkan</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch3-1%20%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD.html">Ch3-1 同步原语</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-2%20%E5%9B%BE%E5%83%8F%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch3-2 图像与缓冲区</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-3%20%E7%AE%A1%E7%BA%BF%E5%B8%83%E5%B1%80%E5%92%8C%E7%AE%A1%E7%BA%BF.html">Ch3-3 管线布局和管线</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-4%20%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93%E5%92%8C%E5%B8%A7%E7%BC%93%E5%86%B2.html">Ch3-4 渲染通道和帧缓冲</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-5%20%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch3-5 命令缓冲区</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-6%20%E6%8F%8F%E8%BF%B0%E7%AC%A6.html">Ch3-6 描述符</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-7%20%E9%87%87%E6%A0%B7%E5%99%A8.html">Ch3-7 采样器</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第四章 着色器</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch4-1%20%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E7%BB%84.html">Ch4-1 着色器模组</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch4-2%20%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8.html">Ch4-2 顶点着色器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch4-3%20%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8.html">Ch4-3 片段着色器</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第五章 封装常用对象</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch5-0%20VkBase%2B.h.html">Ch5-0 VkBase+.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch5-1%20%E5%90%84%E7%A7%8D%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch5-1 各种缓冲区</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第七章 基础示例</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Ch7-1%20%E5%88%9D%E8%AF%86%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch7-1 初识顶点缓冲区</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch7-2%20%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch7-2 初识索引缓冲区</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch7-3%20%E5%88%9D%E8%AF%86push%20constant.html">Ch7-3 初识push constant</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch7-4%20%E5%88%9D%E8%AF%86uniform%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch7-4 初识uniform缓冲区</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Ch7-5 拷贝图像到屏幕</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">将图像拷贝到交换链图像的流程</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">读取图像数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bootscreen">BootScreen</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">从暂存缓冲区到交换链图像</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">从暂存缓冲区到暂存图像</a></li>
<li class="toctree-l2"><a class="reference internal" href="#blit">Blit命令</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EasyVulkan</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Ch7-5 拷贝图像到屏幕</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ch7-5">
<h1>Ch7-5 拷贝图像到屏幕<a class="headerlink" href="#ch7-5" title="Permalink to this heading"></a></h1>
<p>
    本节的<span class="path">main.cpp</span>对应示例代码中的：<a href="https://github.com/EasyVulkan/EasyVulkan.github.io/tree/main/solution/EasyVulkan_Ch7/Ch7-5.hpp">Ch7-5.hpp</a>
</p>
<p>
    由于到成功渲染出图像为止有诸多步骤，本套教程中分两步走。
    <br>
    本节学习如何使用stb_image读取图像数据、如何将图像数据拷贝到设备内存，以及blit命令。
</p><section id="id1">
<h2>将图像拷贝到交换链图像的流程<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h2>
<p>
    将图像数据直接拷贝或blit到交换链图像，是在屏幕上显示内容的最快方式。
    <br>
    当你的程序有大量的需要加载或创建的资源时，你可以通过这一方法来显示所谓的“启动画面”，展示一张诸如你的LOGO之类的图像。
</p>
<p>
    以下是将图像数据拷贝到交换链图像的流程：
    <br>
    1.读取图像数据到CPU内存
    <br>
    2.将图像数据从CPU内存拷贝到暂存缓冲区
    <br>
    <strong>接下来，根据图像尺寸与交换链图像是否相同，有两个分支：</strong>
    <br>
    （A：若图像与交换链图像尺寸相同）
    <br>
    A-3.将图像数据从暂存缓冲区直接拷贝到交换链图像
    <br>
    （B：若图像与交换链图像尺寸不同）
    <br>
    B-3.获取与暂存缓冲区混叠的暂存图像，若无法混叠，将图像数据从暂存缓冲区直接拷贝到一张新建的暂存图像
    <br>
    B-4.将图像数据从暂存图像blit到交换链图像
</p></section>
<section id="id2">
<h2>读取图像数据<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h2>
<p>
    考虑读取图像的两种情形：
    <br>
    1.直接从硬盘读取文件
    <br>
    2.从内存读取文件数据
    <br>
    如果你想把所有东西（图像、音频等会在你的程序里用到的资源）都打包进单个可执行程序，或把资源扔进dll，那么得用平台特定的函数从程序自身或dll读取资源，获得资源的内存地址。如果你有这一需求的话，得准备好从内存读取的相应函数。
</p>
<p>
    为了省去重复的代码，我打算将两种情形统一到同一个模板函数中，然后用根据参数类型运用运行期分支。
    <br>
    在<span class="path">VkBase+.h</span>中，vulkan命名空间中加入类<span class="type">texture</span>，并定义受保护静态成员函数<span class="fn">LoadFile_Internal</span>：
</p>
<pre class="code">
<span class="kw">class</span> <span class="type">texture</span> {
<span class="kw">protected</span>:
    <span class="kw">static</span> std::<span class="type">unique_ptr</span>&lt;<span class="type">uint8_t</span>[]&gt; <span class="fn">LoadFile_Internal</span>(
        <span class="kw">const auto</span>* address,          <span class="cmt">//字符串指针，或资源的内存地址</span>
        <span class="type">size_t</span> fileSize,              <span class="cmt">//文件大小，当且仅当传入的是资源的内存地址时有需要</span>
        <span class="type">VkExtent2D</span>&amp; extent,           <span class="cmt">//图像大小，将由stb_image的函数写入</span>
        <span class="type">formatInfo</span> requiredFormatInfo)<span class="cmt">//对读取所得数据的格式要求</span>
    {
        <span class="cmt">/*待填充*/</span>
        <span class="kw">void</span>* pImageData = <span class="kw">nullptr</span>;<span class="cmt">//用于接收读取到的图像数据</span>
        <span class="cmt">//运行期分支：若传入的address是文件路径（字符串）</span>
        <span class="kw">if constexpr</span> (std::<span class="cncpt">same_as</span>&lt;<span class="kw">decltype</span>(address), <span class="kw">const char</span>*&gt;) {
            <span class="cmt">/*待填充*/</span>
        }
        <span class="cmt">//运行期分支：若传入的address是内存地址</span>
        <span class="kw">if constexpr</span> (std::<span class="cncpt">same_as</span>&lt;<span class="kw">decltype</span>(address), <span class="kw">const char</span>*&gt;) {
            <span class="cmt">/*待填充*/</span>
        }
        <span class="kw">return</span> std::<span class="type">unique_ptr</span>&lt;<span class="type">uint8_t</span>[]&gt;(<span class="kw">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(pImageData));
    }
};
</pre>
<p>
    除了<span class="var">pImageData</span>外，stb_image的读图函数还会要求以下参数：
</p>
<pre class="code">
<span class="cmt">//用于接收长和宽，extent.width和extent.height是uint32_t，因此需要转换</span>
<span class="kw">int</span>&amp; width = <span class="kw">reinterpret_cast</span>&lt;<span class="kw">int</span>&amp;&gt;(extent.width);
<span class="kw">int</span>&amp; height = <span class="kw">reinterpret_cast</span>&lt;<span class="kw">int</span>&amp;&gt;(extent.height);
<span class="cmt">//用于接收原始色彩通道数，读完图后我用不着它，所以也没有将其初始化</span>
<span class="kw">int</span> channelCount;
</pre>
<p>
    有些格式要求是无法满足的，因此加入在Debug Build下检查<span class="var">requiredFormatInfo</span>的代码：
</p>
<pre class="code">
<span class="pragma">#ifndef</span> <span class="mcr">NDEBUG</span>
<span class="kw">if</span> (<span class="cmt">//若要求数据为浮点数，stb_image只支持32位浮点数</span>
    (requiredFormatInfo.rawDataType == formatInfo::<span class="type">floatingPoint</span> &amp;&amp; requiredFormatInfo.sizePerComponent == 4) ||
    <span class="cmt">//若要求数据为整形，stb_image只支持8位或16位每通道</span>
    (requiredFormatInfo.rawDataType == formatInfo::<span class="type">integer</span> &amp;&amp; requiredFormatInfo.sizePerComponent &gt;= 1 &amp;&amp; requiredFormatInfo.sizePerComponent &lt;= 2))
    <span class="cmt">/*空表达式*/</span>;
<span class="kw">else</span>
    outStream &lt;&lt; std::<span class="fn">format</span>(<span class="str">&quot;[ texture ] ERROR\nRequired format is not available for source image data!\n&quot;</span>),
    <span class="fn">abort</span>();
<span class="pragma">#endif</span>
</pre>
<p>
    做掉<span class="kw">else</span>分支，则目前为止<span class="fn">LoadFile_Internal</span>(...)为：
</p>
<pre class="code">
<span class="kw">static</span> std::<span class="type">unique_ptr</span>&lt;<span class="type">uint8_t</span>[]&gt; <span class="fn">LoadFile_Internal</span>(<span class="kw">const auto</span>* address, <span class="type">size_t</span> fileSize, <span class="type">VkExtent2D</span>&amp; extent, <span class="type">formatInfo</span> requiredFormatInfo) {
<span class="pragma">#ifndef</span> <span class="mcr">NDEBUG</span>
    <span class="kw">if</span> (!(requiredFormatInfo.rawDataType == formatInfo::<span class="type">floatingPoint</span> &amp;&amp; requiredFormatInfo.sizePerComponent == 4) &amp;&amp;
        !(requiredFormatInfo.rawDataType == formatInfo::<span class="type">integer</span> &amp;&amp; requiredFormatInfo.sizePerComponent &amp;&amp; requiredFormatInfo.sizePerComponent &lt;= 2))
        outStream &lt;&lt; std::<span class="fn">format</span>(<span class="str">&quot;[ texture ] ERROR\nRequired format is not available for source image data!\n&quot;</span>),
        <span class="fn">abort</span>();
<span class="pragma">#endif</span>
    <span class="kw">int</span>&amp; width = <span class="kw">reinterpret_cast</span>&lt;<span class="kw">int</span>&amp;&gt;(extent.width);
    <span class="kw">int</span>&amp; height = <span class="kw">reinterpret_cast</span>&lt;<span class="kw">int</span>&amp;&gt;(extent.height);
    <span class="kw">int</span> channelCount;
    <span class="kw">void</span>* pImageData = <span class="kw">nullptr</span>;
    <span class="kw">if constexpr</span> (std::<span class="cncpt">same_as</span>&lt;<span class="kw">decltype</span>(address), <span class="kw">const char</span>*&gt;) {
        <span class="cmt">/*待填充*/</span>
    }
    <span class="kw">if constexpr</span> (std::<span class="cncpt">same_as</span>&lt;<span class="kw">decltype</span>(address), <span class="kw">const</span> <span class="type">uint8_t</span>*&gt;) {
        <span class="cmt">/*待填充*/</span>
    }
    <span class="kw">return</span> std::<span class="type">unique_ptr</span>&lt;<span class="type">uint8_t</span>[]&gt;(<span class="kw">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(pImageData));
}
</pre>
<ul>
    <li>
        <p>
            std::<span class="cncpt">same_as</span>是一个C++概念（<span class="kw">concept</span>），根据运行期的类型判断被转为相应布尔值，若类型一致则为真。若对C++概念不熟悉，请自行参阅相关文档。
        </p>
    </li>
</ul>
<p>
    用<span class="fn">stbi_load</span>(...)将图像文件读取为8位整形序列：
</p>
<div class="wy-table-responsive"><table class="docutils align-default">
    <colgroup>
        <col style="width: 30%">
        <col style="width: 70%">
    </colgroup>
    <thead>
        <tr class="row-odd">
            <th class="head" colspan="2"><p><span class="mcr">STBIDEF</span> <span class="type">stbi_uc</span>* <span class="fn">stbi_load</span>(...) 的参数说明</p></th>
        </tr>
    </thead>
    <tbody>
        <tr class="row-even">
            <td><p><span class="kw">const char</span>* filename</p></td>
            <td><p>文件路径</p></td>
        </tr>
        <tr class="row-odd">
            <td><p><span class="kw">int</span>* x</p></td>
            <td><p>输出图像宽到*x</p></td>
        </tr>
        <tr class="row-even">
            <td><p><span class="kw">int</span>* y</p></td>
            <td><p>输出图像宽到*y</p></td>
        </tr>
        <tr class="row-odd">
            <td><p><span class="kw">int</span>* comp</p></td>
            <td><p>输出图像色彩通道数到*comp</p></td>
        </tr>
        <tr class="row-even">
            <td><p><span class="kw">int</span> req_comp</p></td>
            <td><p>若非0，图像色彩通道数会被减少或补齐到req_comp</p></td>
        </tr>
    </tbody>
</table></div>
<ul>
    <li>
        <p>
            该函数自动识别文件类型，支持bmp、tga、png、jpeg、hdr等常见格式（具体请自行参见文件内注释）。如果你事先确定文件类型，也可以直接用诸如<span class="fn">stbi__tga_load</span>(...)之类具体格式的读取函数。
        </p>
    </li>
    <li>
        <p>
            若函数执行成功，返回读取所得数据的内存地址，否则为<span class="kw">nullptr</span>。
        </p>
    </li>
</ul>
<p>
    类似地，用<span class="fn">stbi_load_16</span>(...)将图像读取为16位整形序列，用<span class="fn">stbi_loadf</span>(...)将图像读取为32位浮点数序列，参数与<span class="fn">stbi_load</span>(...)一致。
    <br>
    于是，根据<span class="var">requiredFormatInfo</span>中的各种要求，有以下分支：
</p>
<pre class="code">
<span class="kw">if</span> (requiredFormatInfo.rawDataType == formatInfo::<span class="enum">integer</span>)
    <span class="kw">if</span> (requiredFormatInfo.sizePerComponent == 1)
        pImageData = <span class="fn">stbi_load</span>(address, &amp;width, &amp;height, &amp;channelCount, requiredFormatInfo.componentCount);
    <span class="kw">else</span>
        pImageData = <span class="fn">stbi_load_16</span>(address, &amp;width, &amp;height, &amp;channelCount, requiredFormatInfo.componentCount);
<span class="kw">else</span>
    pImageData = <span class="fn">stbi_loadf</span>(address, &amp;width, &amp;height, &amp;channelCount, requiredFormatInfo.componentCount);
<span class="kw">if</span> (!pImageData)
    outStream &lt;&lt; std::<span class="fn">format</span>(<span class="str">&quot;[ texture ] ERROR\nFailed to load the file: {}\n&quot;</span>, address);
</pre>
<p>
    从内存读取文件数据时，步骤几乎一致，差别仅在于：要提供文件数据的大小，以及各个读取函数替换成对应的有_from_memory后缀的版本：
</p>
<div class="wy-table-responsive"><table class="docutils align-default">
    <colgroup>
        <col style="width: 30%">
        <col style="width: 70%">
    </colgroup>
    <thead>
        <tr class="row-odd">
            <th class="head" colspan="2"><p><span class="mcr">STBIDEF</span> <span class="type">stbi_uc</span>* <span class="fn">stbi_load_from_memory</span>(...) 的参数说明</p></th>
        </tr>
    </thead>
    <tbody>
        <tr class="row-even">
            <td><p><span class="kw">const</span> <span class="type">stbi_uc</span>* buffer</p></td>
            <td><p>文件数据的内存地址</p></td>
        </tr>
        <tr class="row-odd">
            <td><p><span class="kw">int</span> len</p></td>
            <td><p>文件数据的大小</p></td>
        </tr>
        <tr class="row-even">
            <td><p><span class="kw">int</span>* x</p></td>
            <td><p>输出图像宽到*x</p></td>
        </tr>
        <tr class="row-odd">
            <td><p><span class="kw">int</span>* y</p></td>
            <td><p>输出图像宽到*y</p></td>
        </tr>
        <tr class="row-even">
            <td><p><span class="kw">int</span>* comp</p></td>
            <td><p>输出图像色彩通道数到*comp</p></td>
        </tr>
        <tr class="row-odd">
            <td><p><span class="kw">int</span> req_comp</p></td>
            <td><p>若非0，图像色彩通道数会被减少或补齐到req_comp</p></td>
        </tr>
    </tbody>
</table></div>
<p>
    既然len的类型是<span class="kw">int</span>，那么显然，文件数据不能达到2G。
    <br>
    最后整个<span class="fn">LoadFile_Internal</span>(...)如下：
</p>
<pre class="code">
<span class="kw">static</span> std::<span class="type">unique_ptr</span>&lt;<span class="type">uint8_t</span>[]&gt; <span class="fn">LoadFile_Internal</span>(<span class="kw">const auto</span>* address, <span class="type">size_t</span> fileSize, <span class="type">VkExtent2D</span>&amp; extent, <span class="type">formatInfo</span> requiredFormatInfo) {
<span class="pragma">#ifndef</span> <span class="mcr">NDEBUG</span>
    <span class="kw">if</span> (!(requiredFormatInfo.rawDataType == formatInfo::<span class="type">floatingPoint</span> &amp;&amp; requiredFormatInfo.sizePerComponent == 4) &amp;&amp;
        !(requiredFormatInfo.rawDataType == formatInfo::<span class="type">integer</span> &amp;&amp; requiredFormatInfo.sizePerComponent &amp;&amp; requiredFormatInfo.sizePerComponent &lt;= 2))
        outStream &lt;&lt; std::<span class="fn">format</span>(<span class="str">&quot;[ texture ] ERROR\nRequired format is not available for source image data!\n&quot;</span>),
        <span class="fn">abort</span>();
<span class="pragma">#endif</span>
    <span class="kw">int</span>&amp; width = <span class="kw">reinterpret_cast</span>&lt;<span class="kw">int</span>&amp;&gt;(extent.width);
    <span class="kw">int</span>&amp; height = <span class="kw">reinterpret_cast</span>&lt;<span class="kw">int</span>&amp;&gt;(extent.height);
    <span class="kw">int</span> channelCount;
    <span class="kw">void</span>* pImageData = <span class="kw">nullptr</span>;
    <span class="kw">if constexpr</span> (std::<span class="cncpt">same_as</span>&lt;<span class="kw">decltype</span>(address), <span class="kw">const char</span>*&gt;) {
        <span class="kw">if</span> (requiredFormatInfo.rawDataType == formatInfo::<span class="enum">integer</span>)
            <span class="kw">if</span> (requiredFormatInfo.sizePerComponent == 1)
                pImageData = <span class="fn">stbi_load</span>(address, &amp;width, &amp;height, &amp;channelCount, requiredFormatInfo.componentCount);
            <span class="kw">else</span>
                pImageData = <span class="fn">stbi_load_16</span>(address, &amp;width, &amp;height, &amp;channelCount, requiredFormatInfo.componentCount);
        <span class="kw">else</span>
            pImageData = <span class="fn">stbi_loadf</span>(address, &amp;width, &amp;height, &amp;channelCount, requiredFormatInfo.componentCount);
        <span class="kw">if</span> (!pImageData)
            outStream &lt;&lt; std::<span class="fn">format</span>(<span class="str">&quot;[ texture ] ERROR\nFailed to load the file: {}\n&quot;</span>, address);
    }
    <span class="kw">if constexpr</span> (std::<span class="cncpt">same_as</span>&lt;<span class="kw">decltype</span>(address), <span class="kw">const</span> <span class="type">uint8_t</span>*&gt;) {
        <span class="kw">if</span> (fileSize > <span class="mcr">INT32_MAX</span>) {
            outStream &lt;&lt; std::<span class="fn">format</span>(<span class="str">&quot;[ texture ] ERROR\nFailed to load image data from the given address! Data size must be less than 2G!\n&quot;</span>);
            <span class="kw">return</span> {};
        }
        <span class="kw">if</span> (requiredFormatInfo.rawDataType == formatInfo::<span class="enum">integer</span>)
            <span class="kw">if</span> (requiredFormatInfo.sizePerComponent == 1)
                pImageData = <span class="fn">stbi_load_from_memory</span>(address, fileSize, &amp;width, &amp;height, &amp;channelCount, requiredFormatInfo.componentCount);
            <span class="kw">else</span>
                pImageData = <span class="fn">stbi_load_16_from_memory</span>(address, fileSize, &amp;width, &amp;height, &amp;channelCount, requiredFormatInfo.componentCount);
        <span class="kw">else</span>
            pImageData = <span class="fn">stbi_loadf_from_memory</span>(address, fileSize, &amp;width, &amp;height, &amp;channelCount, requiredFormatInfo.componentCount);
        <span class="kw">if</span> (!pImageData)
            outStream &lt;&lt; std::<span class="fn">format</span>(<span class="str">&quot;[ texture ] ERROR\nFailed to load image data from the given address!\n&quot;</span>);
    }
    <span class="kw">return</span> std::<span class="type">unique_ptr</span>&lt;<span class="type">uint8_t</span>[]&gt;(<span class="kw">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(pImageData));
}
</pre>
<p>
    如果你需要根据图片的通道数<span class="var">channelCount</span>及你指定的其他参数确定对应的<span class="type">VkFormat</span>，自行修改函数。会有些麻烦，需要写一张映射表。
</p>
<p>
    注意到我给上述函数起的名字有_Internal后缀，你可能已经意识到了我接下来要干什么：
</p>
<pre class="code">
<span class="kw">class</span> <span class="type">texture</span> {
<span class="kw">protected</span>:
    <span class="kw">static</span> std::<span class="type">unique_ptr</span>&lt;<span class="type">uint8_t</span>[]&gt; <span class="fn">LoadFile_Internal</span>(<span class="kw">const auto</span>* address, <span class="type">size_t</span> fileSize, <span class="type">VkExtent2D</span>&amp; extent, <span class="type">formatInfo</span> requiredFormatInfo) {
        <span class="cmt">/*...*/</span>
    }
<span class="kw">public</span>:
    [[nodiscard]]
    <span class="kw">static</span> std::<span class="type">unique_ptr</span>&lt;<span class="type">uint8_t</span>[]&gt; <span class="fn">LoadFile</span>(<span class="kw">const char</span>* filepath, <span class="type">VkExtent2D</span>&amp; extent, <span class="type">formatInfo</span> requiredFormatInfo) {
        <span class="kw">return</span> <span class="kw">LoadFile_Internal</span>(filepath, 0, extent, requiredFormatInfo);
    }
    [[nodiscard]]
    <span class="kw">static</span> std::<span class="type">unique_ptr</span>&lt;<span class="type">uint8_t</span>[]&gt; <span class="fn">LoadFile</span>(<span class="kw">const</span> <span class="type">uint8_t</span>* fileBinaries, <span class="type">size_t</span> fileSize, <span class="type">VkExtent2D</span>&amp; extent, <span class="type">formatInfo</span> requiredFormatInfo) {
        <span class="kw">return</span> <span class="kw">LoadFile_Internal</span>(fileBinaries, fileSize, extent, requiredFormatInfo);
    }
};
</pre>
<p>
    顺便，提供在Windows上从exe或dll读取资源的函数。
    <br>
    关于以下代码具体的含义，以及Visual Studio中如何打包资源，因与Vulkan无关，请自行搜索相关教程。
</p>
<pre class="code">
std::<span class="type">pair</span>&lt;<span class="kw">const</span> <span class="type">uint8_t</span>*, <span class="type">size_t</span>&gt; <span class="fn">LoadResourceFromModule</span>(<span class="type">int32_t</span> resourceId, <span class="type">HMODULE</span> hModule = <span class="mcr">NULL</span>) {
    <span class="kw">if</span> (<span class="type">HRSRC</span> hResource = <span class="fn">FindResource</span>(hModule, <span class="mcr">MAKEINTRESOURCE</span>(resourceId), <span class="mcr">RT_RCDATA</span>))
        <span class="kw">if</span> (<span class="type">HGLOBAL</span> hData = <span class="fn">LoadResource</span>(hModule, hResource))
            <span class="kw">if</span> (<span class="kw">const</span> <span class="type">uint8_t</span>* pData = <span class="kw">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(<span class="fn">LockResource</span>(hData)))
                <span class="kw">return</span> { pData, <span class="fn">SizeofResource</span>(hModule, hResource) };
    <span class="kw">return</span> {};
}
</pre></section>
<section id="bootscreen">
<h2>BootScreen<a class="headerlink" href="#bootscreen" title="Permalink to this heading"></a></h2>
<p>
    我们得有一个函数来放这一节接下来要写的东西。
    <br>
    于是乎，既然本节的目标就只是拷贝图像到屏幕，那么如我前面所说的“启动画面”这一非常简单的应用场景就非常合适。
    <br>
    在<span class="path">EasyVulkan.hpp</span>，easyVulkan命名空间中加入：
</p>
<pre class="code">
<span class="kw">void</span> <span class="fn">BootScreen</span>(<span class="kw">const char</span>* imagePath, <span class="type">VkFormat</span> imageFormat) {
    <span class="type">VkExtent2D</span> imageExtent;
    std::<span class="type">unique_ptr</span>&lt;<span class="type">uint8_t</span>[]&gt; pImageData = <span class="type">texture2d</span>::<span class="fn">LoadFile</span>(imagePath, imageExtent, <span class="fn">FormatInfo</span>(imageFormat));
    <span class="kw">if</span> (!pImageData)
        <span class="kw">return</span>;<span class="cmt">//这里我就偷个懒，不写错误信息了</span>
    <span class="cmt">/*待填充*/</span>
}
</pre>
<p>
    接着先来学习下前面学过的东西。
    <br>
    于是我现在不需要构建渲染循环，只需要提交一次命令缓冲区就够了，不用考虑之后的事，且命令缓冲区中不需要渲染通道。
    <br>
    那么需要哪些对象，并调用哪些函数呢？如果你尚不能信手拈来地写一个渲染循环，那么我建议你在此先回忆一下。
    <br>
    ...
    <br>
    显然需要命令缓冲区，因为已经直接写在了题设里。
    <br>
    ...
    <br>
    录制、提交并等待命令缓冲区需要配一个栅栏。
    <br>
    ...
    <br>
    既然要用到交换链图像，那么肯定得先获得它。在我的封装中，这一步用<span class="type">graphicsBase</span>::SwapImage(...)进行。
    <br>
    ...
    <br>
    于是，函数加入如下内容：
</p>
<pre class="code">
<span class="kw">void</span> <span class="fn">BootScreen</span>(<span class="kw">const char</span>* imagePath, <span class="type">VkFormat</span> imageFormat) {
    <span class="cmt">//用先前写的函数从硬盘读图</span>
    <span class="type">VkExtent2D</span> imageExtent;
    std::<span class="type">unique_ptr</span>&lt;<span class="type">uint8_t</span>[]&gt; pImageData = <span class="type">texture2d</span>::<span class="fn">LoadFile</span>(imagePath, imageExtent, <span class="fn">FormatInfo</span>(imageFormat));
    <span class="kw">if</span> (!pImageData)
        <span class="kw">return</span>;<span class="cmt">//这里我就偷个懒，不写错误信息了</span>
    <span class="cmt">/*待填充*/</span>

    <span class="cmt">//创建同步对象</span>
    <span class="type">semaphore</span> semaphore_imageIsAvailable;
    <span class="type">fence</span> fence;
    <span class="cmt">//分配命令缓冲区</span>
    <span class="type">commandBuffer</span> commandBuffer;
    <span class="type">graphicsBase</span>::<span class="fn">Plus</span>().<span class="fn">CommandPool_Graphics</span>().<span class="fn">AllocateBuffers</span>(commandBuffer);

    <span class="cmt">//获取交换链图像</span>
    <span class="type">graphicsBase</span>::<span class="fn">Base</span>().<span class="fn">SwapImage</span>(semaphore_imageIsAvailable);

    <span class="cmt">//录制命令缓冲区</span>
    commandBuffer.<span class="fn">Begin</span>(<span class="enum">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</span>);
    <span class="cmt">/*待填充*/</span>
    commandBuffer.<span class="fn">End</span>();

    <span class="cmt">//提交命令缓冲区</span>
    <span class="type">VkPipelineStageFlags</span> waitDstStage = <span class="enum">VK_PIPELINE_STAGE_TRANSFER_BIT</span>;
    <span class="type">VkSubmitInfo</span> submitInfo = {
        .waitSemaphoreCount = 1,
        .pWaitSemaphores = semaphore_imageIsAvailable.<span class="fn">Address</span>(),
        .pWaitDstStageMask = &amp;waitDstStage,
        .commandBufferCount = 1,
        .pCommandBuffers = commandBuffer.<span class="fn">Address</span>()
    };
    <span class="type">graphicsBase</span>::<span class="fn">Base</span>().<span class="fn">SubmitCommandBuffer_Graphics</span>(submitInfo, fence);
    <span class="cmt">//等待命令执行完毕</span>
    fence.<span class="fn">WaitAndReset</span>();
    <span class="cmt">//呈现图像</span>
    <span class="type">graphicsBase</span>::<span class="fn">Base</span>().<span class="fn">PresentImage</span>();

    <span class="cmt">//别忘了释放命令缓冲区</span>
    <span class="type">graphicsBase</span>::<span class="fn">Plus</span>().<span class="fn">CommandPool_Graphics</span>().<span class="fn">FreeBuffers</span>(commandBuffer);
}
</pre>
<ul>
    <li>
        <p>
            因为之后会使用的拷贝和Blit命令都是传输命令，所以<span class="var">waitDstStage</span>是<span class="enum">VK_PIPELINE_STAGE_TRANSFER_BIT</span>。
        </p>
    </li>
    <li>
        <p>
            因为这里的应用场景不要求同步粒度，因此我直接在呈现图像前等待<span class="var">fence</span>，而不必使用第二个信号量。
        </p>
    </li>
</ul>
<p>
    TODO
</p>
<pre class="code">

</pre></section>
<section id="id3">
<h2>从暂存缓冲区到交换链图像<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h2>
<p>

</p>
<pre class="code">

</pre></section>
<section id="id4">
<h2>从暂存缓冲区到暂存图像<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h2>
<p>

</p>
<pre class="code">

</pre></section>
<section id="blit">
<h2>Blit命令<a class="headerlink" href="#blit" title="Permalink to this heading"></a></h2>
<p>

</p>
<pre class="code">

</pre></section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Ch7-4%20%E5%88%9D%E8%AF%86uniform%E7%BC%93%E5%86%B2%E5%8C%BA.html" class="btn btn-neutral float-left" title="Ch7-4 初识uniform缓冲区" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021, Qiao YeCheng.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>