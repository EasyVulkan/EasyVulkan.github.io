

<!DOCTYPE html>
<html class="writer-html5" lang="chs" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Ch2-3 天哪，是三角形 &mdash; EasyVulkan</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Ch2-4 即时帧与队列族所有权转移" href="Ch2-4%20%E5%8D%B3%E6%97%B6%E5%B8%A7%E4%B8%8E%E9%98%9F%E5%88%97%E6%97%8F%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB.html" />
    <link rel="prev" title="Ch2-2 Rendering Loop" href="Ch2-2%20Rendering%20Loop.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> EasyVulkan
          

          
            
            <img src="_static/logo1.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">第一章 从零到交换链</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch1-0%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html">Ch1-0 准备工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-1%20%E5%88%9B%E5%BB%BAGLFW%E7%AA%97%E5%8F%A3.html">Ch1-1 创建GLFW窗口</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-2%20%E5%88%9B%E5%BB%BAVk%E5%AE%9E%E4%BE%8B%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87.html">Ch1-2 创建Vk实例与逻辑设备</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-3%20%E5%88%9B%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE.html">Ch1-3 创建交换链</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-4%20%E6%89%BF%E5%89%8D%E5%90%AF%E5%90%8E.html">Ch1-4 承前启后</a></li>
</ul>
<p class="caption"><span class="caption-text">第二章 基础绘制</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Ch2-1%20%E5%88%9B%E5%BB%BA%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93.html">Ch2-1 创建渲染通道</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch2-2%20Rendering%20Loop.html">Ch2-2 Rendering Loop</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Ch2-3 天哪，是三角形</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#glsl">最基础的GLSL着色器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">GLSL版本声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">着色器阶段声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">变量类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">着色器输入输出</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">其它</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#spir-v">将着色器编译为Spir-V代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">创建渲染管线</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">创建渲染管线布局</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">创建着色器模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">创建渲染通道</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id11">绘制三角形</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Ch2-4%20%E5%8D%B3%E6%97%B6%E5%B8%A7%E4%B8%8E%E9%98%9F%E5%88%97%E6%97%8F%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB.html">Ch2-4 即时帧与队列族所有权转移</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EasyVulkan</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Ch2-3 天哪，是三角形</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="ch2-3">
<h1>Ch2-3 天哪，是三角形<a class="headerlink" href="#ch2-3" title="Permalink to this headline">¶</a></h1>
<div class="line-block">
<div class="line">这节课中我们会学习基础的Vulkan专用GLSL方言，并创建渲染管线。</div>
<div class="line">所谓方言是因为GLSL是为OpenGL开发的着色器语言，用于Vulkan的话会有点差别，我不会细讲这里面的差别 —— 毕竟这教程面向的并不只是已经会OpenGL的读者。</div>
</div>
<div class="section" id="glsl">
<h2>最基础的GLSL着色器<a class="headerlink" href="#glsl" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">让我们在项目根目录下新建一个叫 <code class="docutils literal notranslate"><span class="pre">shader</span></code> 的文件夹，并在其下新建两个文件：</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">FirstTriangle.vert.shader</span></code> ：</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#version 450</span>
<span class="c1">#pragma shader_stage(vertex)</span>

<span class="n">vec2</span> <span class="n">positions</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span>    <span class="mi">0</span><span class="p">,</span> <span class="o">-.</span><span class="mi">5</span><span class="n">f</span> <span class="p">},</span>
    <span class="p">{</span> <span class="o">-.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span>  <span class="o">.</span><span class="mi">5</span><span class="n">f</span> <span class="p">},</span>
    <span class="p">{</span>  <span class="o">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span>  <span class="o">.</span><span class="mi">5</span><span class="n">f</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">gl_VertexIndex</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">FirstTriangle.frag.shader</span></code> ：</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#version 450</span>
<span class="c1">#pragma shader_stage(fragment)</span>

<span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec4</span> <span class="n">o_Color</span><span class="p">;</span>

<span class="n">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">o_Color</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">任何一个图形管线都得至少具有顶点（vertex）和片段（fragment）两个着色器。</div>
</div>
<div class="section" id="id1">
<h3>命名<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">命名上如果用 <code class="docutils literal notranslate"><span class="pre">名称.阶段简写</span></code> ，编译时会更省事，但是我没安装额外的插件，并且我想要VS给我最起码的语法高亮，使用.shader作为后缀名可以满足这一点。</div>
</div>
</div>
<div class="section" id="id2">
<h3>GLSL版本声明<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">在GLSL着色器中，必须在开头声明版本：</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">#version</span> <span class="pre">版本号</span></code></div>
<div class="line">我用450并没有什么特殊原因，先入为主沿用至今罢了。Vulkan所需的GLSL最低版本我已不记得，你可以总是用最新的，目前应该是460，这跟最新的OpenGL有哪些特性无关，如果你用了不能使用的特性或关键字， <code class="docutils literal notranslate"><span class="pre">glslc.exe</span></code> （我们将会使用的编译工具）会报错，所以你总是会知道的。</div>
</div>
</div>
<div class="section" id="id3">
<h3>着色器阶段声明<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">shader_stage(阶段全称)</span></code></div>
<div class="line">这个并不是必须的，但是我选择的编译方式需要我声明阶段。</div>
</div>
</div>
<div class="section" id="id4">
<h3>变量类型<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">GLSL中有以下内置标量类型：</div>
<div class="line"><strong>bool, int, uint, float, double</strong></div>
<div class="line">int和uint和float都是32位，double是64位，硬件无关</div>
<div class="line">有以下内置矢量类型：</div>
<div class="line"><strong>bvecN, ivecN, uvecN, vecN, dvecN</strong></div>
<div class="line">N的范围是2到4</div>
<div class="line">最常用的是vecN，然后是ivecN, uvecN</div>
<div class="line">这些类型在GLM数学库中也是都支持的。</div>
<div class="line">如果你使用某个矢量的某些分量，它可以直接作为一个更短的矢量来用，比如：</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span> <span class="n">pos</span><span class="p">;</span>
<span class="n">vec2</span> <span class="n">pos2d</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">写死在着色器中的全局常量的写法与C语言类似，不做说明。</div>
<div class="line">OpenGL转来的程序员注意，Vulkan的标准化设备坐标系中，左上角为(-1,-1)，右下角为( 1, 1)，y轴正方向同OpenGL相反。</div>
</div>
</div>
<div class="section" id="id5">
<h3>着色器输入输出<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">layout</span></code> 声明符，其作用众多，我们以后慢慢讲，先只讲这次用到了的。</div>
<div class="line">在片段着色器中，layout声明符声明了一个输出， <code class="docutils literal notranslate"><span class="pre">location</span> <span class="pre">=</span> <span class="pre">0</span></code> 表示输出到索引为0的附件。</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">vec4</span> <span class="pre">o_Color</span></code> vec4与我们交换链图像的格式（RGBA四通道UNORM）匹配， <code class="docutils literal notranslate"><span class="pre">o_Color</span></code> 并无特别含义，变量命名是随意的，我的命名习惯是o_作为输出变量的前缀后跟大写开头驼峰。</div>
<div class="line">顶点着色器中没有声明任何输入输出，因为顶点着色器必须要输出至内置变量 <code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> 。</div>
<div class="line">你可以在顶点着色器中定义输入（来自顶点数据和实例化数据），以及输出（然后通过location匹配到片段着色器中的相应输入），不过这就是更往后的课程内容了。</div>
</div>
</div>
<div class="section" id="id6">
<h3>其它<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">gl_VertexIndex</span></code> 是顶点索引，我们会绘制三个顶点，来取出 <code class="docutils literal notranslate"><span class="pre">positions</span></code> 的三个vec2，构成三角形。</div>
</div>
<div class="line-block">
<div class="line">注意到 <code class="docutils literal notranslate"><span class="pre">vec4(positions[gl_VertexIndex],</span> <span class="pre">0,</span> <span class="pre">1)</span></code> 中 <code class="docutils literal notranslate"><span class="pre">positions[gl_VertexIndex]</span></code> 直接取代了两个分量的位置，事实上你还能 vec4(x, 一个vec2, z) 或者 vec4(x, y, 一个vec2)，也就是说你能用一个更短的的矢量取代任意相应分量的位置。</div>
</div>
<div class="line-block">
<div class="line">主函数必须是 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">主函数名称()</span></code> ，建议主函数名称是main。</div>
<div class="line">然后，既然有所谓主函数，你当然还能在着色器里定义其他函数。</div>
</div>
<div class="line-block">
<div class="line">我对数字的写法并没有统一，但这些常值当然都会直接被编译成float，因为它们被使用在vec类型的构造函数中。</div>
</div>
</div>
</div>
<div class="section" id="spir-v">
<h2>将着色器编译为Spir-V代码<a class="headerlink" href="#spir-v" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">以下依旧以Windows为例。</div>
</div>
<div class="line-block">
<div class="line">如果你对着色器采用了 <code class="docutils literal notranslate"><span class="pre">名称.阶段简写</span></code> 的命名方式，那么你可以采用最通俗省事的编译方式：</div>
<div class="line">在shader文件夹的地址栏中输入cmd，以在该路径下打开命令行窗口，输入：</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">C:/VulkanSDK/1.2.154.1/Bin/glslc.exe</span> <span class="pre">FirstTriangle.vert</span> <span class="pre">-o</span> <span class="pre">FirstTriangle.vert.spv</span></code></div>
<div class="line">格式：编译工具路劲 被编译的GLSL文件 -o 输出文件名（建议是spv结尾）</div>
<div class="line">其中-o 表示输出。</div>
<div class="line">使用 <code class="docutils literal notranslate"><span class="pre">.阶段简写</span></code> 作为被编译文件后缀，那么glsl.c就会知道你编译的是哪个阶段的着色器</div>
</div>
<div class="line-block">
<div class="line">而我使用的后缀名是.shader，于是：</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">C:/VulkanSDK/1.2.154.1/Bin/glslc.exe</span> <span class="pre">FirstTriangle.vert.shader</span> <span class="pre">-o</span> <span class="pre">FirstTriangle.vert.spv</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">glslc.exe</span></code> 无法通过文件名知晓阶段时，会检查文件内的预编译指令 <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">shader_stage</span></code> ，由此知晓阶段，这是我使用的方式。</div>
</div>
<div class="line-block">
<div class="line">另外如果你没有在文件内声明阶段，也可以显式地指定阶段：</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">C:/VulkanSDK/1.2.154.1/Bin/glslc.exe</span> <span class="pre">FirstTriangle.vert.shader</span> <span class="pre">-fshader-stage=vert</span> <span class="pre">-o</span> <span class="pre">FirstTriangle.vert.spv</span></code></div>
<div class="line">这里多了个参数，语法是： -fshader-stage=阶段简写</div>
</div>
<div class="line-block">
<div class="line">Spir-V仍旧是一种中间语言，在运行Vulkan程序时会被进一步编译成GPU能直接运行的程序。</div>
<div class="line">为什么不事先一步到位地编译？因为不同的显卡驱动所提供的Vulkan实现的编译结果可能不同，涉及到优化等，需要将Spir-V文件编译成最适合相应显卡的程序。</div>
</div>
</div>
<div class="section" id="id7">
<h2>创建渲染管线<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">在 <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> 的全局范围添加以下内容：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">vulkan</span><span class="p">;</span>
<span class="n">pipelineLayout</span> <span class="n">pipelineLayout_triangle</span><span class="p">;</span>
<span class="n">pipeline</span> <span class="n">pipeline_triangle</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">CreateLayout</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/*待填充*/</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">CreatePipeline</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/*待填充*/</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id8">
<h3>创建渲染管线布局<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">创建渲染管线之前得先创建一个渲染管线布局， <span class="type">VkPipelineLayout</span> 指定了渲染管线会如何获取常量。</div>
<div class="line"><span class="kw">struct</span> <span class="type">VkPipelineLayoutCreateInfo</span> {</div>
<div class="line-block">
<div class="line"><span class="type">VkStructureType</span> sType;</div>
<div class="line"><span class="kw">const void</span> * pNext;</div>
<div class="line"><span class="type">VkPipelineLayoutCreateFlags</span> flags;</div>
<div class="line"><span class="type">uint32_t</span> setLayoutCount;</div>
<div class="line"><span class="kw">const</span> <span class="type">VkDescriptorSetLayout</span> * pSetLayouts;</div>
<div class="line"><span class="type">uint32_t</span> pushConstantRangeCount;</div>
<div class="line"><span class="kw">const</span> <span class="type">VkPushConstantRange</span> * pPushConstantRanges;</div>
</div>
<div class="line">};</div>
<div class="line">传递常量的方式一共两种：pushConstant和描述符，我们第一个三角形的shader不需要任何常量，因此直接创建渲染管线布局：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">CreateLayout</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">VkPipelineLayoutCreateInfo</span> <span class="n">pipelineLayoutCreateInfo</span><span class="p">{};</span>
    <span class="n">pipelineLayout_triangle</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">pipelineLayoutCreateInfo</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>创建着色器模块<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">CreatePipeline</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">shader</span> <span class="n">vert_triangle</span><span class="p">(</span><span class="s">&quot;shader/FirstTriangle.vert.spv&quot;</span><span class="p">);</span>
    <span class="k">static</span> <span class="n">shader</span> <span class="n">frag_triangle</span><span class="p">(</span><span class="s">&quot;shader/FirstTriangle.frag.spv&quot;</span><span class="p">);</span>
    <span class="cm">/*待补充*/</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">向我写的 <span class="type">shader</span> 类传入文件地址后会自动创建着色器模块。</div>
<div class="line-block">
<div class="line"><span class="type">shader</span> 会调用以下函数：</div>
</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkResult</span> <span class="nf">Create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filepath</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//用 :type:`ifstream` 打开文件， ``std::ios::ate | std::ios::binary`` 分别表示文件指针移动到文件尾部，以及作为二进制文件打开。</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">file</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">ate</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ shader ]</span><span class="se">\n</span><span class="s">Failed to load the shader file: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">filepath</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">//file.tellg() 表示文件指针到文件头部的距离，单位是字节，所以以此可以取得文件大小。</span>
    <span class="kt">size_t</span> <span class="n">fileSize</span> <span class="o">=</span> <span class="kt">size_t</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">tellg</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">binaries</span><span class="p">(</span><span class="n">fileSize</span><span class="p">);</span>
    <span class="c1">//将指针移回文件起始处，并读取文件到binaries</span>
    <span class="n">file</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">binaries</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">fileSize</span><span class="p">);</span>
    <span class="n">file</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

    <span class="c1">//VkShaderModuleCreateInfo 没什么好讲，一共五个字段，你没看到的两个分别是flags和pNext</span>
    <span class="n">VkShaderModuleCreateInfo</span> <span class="n">shaderModuleCreateInfo</span><span class="p">{};</span>
    <span class="n">shaderModuleCreateInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO</span><span class="p">;</span>
    <span class="n">shaderModuleCreateInfo</span><span class="p">.</span><span class="n">codeSize</span> <span class="o">=</span> <span class="n">binaries</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">shaderModuleCreateInfo</span><span class="p">.</span><span class="n">pCode</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="n">binaries</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
    <span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkCreateShaderModule</span><span class="p">(</span><span class="n">graphicsBase</span><span class="o">::</span><span class="n">Base</span><span class="p">().</span><span class="n">Device</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">shaderModuleCreateInfo</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ shader ]</span><span class="se">\n</span><span class="s">Failed to create a shader module!</span><span class="se">\n</span><span class="s">Error code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">接着填写着色器阶段创建信息：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">VkPipelineShaderStageCreateInfo</span> <span class="n">shaderStageCreateInfos_triangle</span><span class="p">[</span><span class="mi">2</span><span class="p">]{</span>
    <span class="n">vert_triangle</span><span class="p">.</span><span class="n">StageCreateInfo</span><span class="p">(</span><span class="n">VK_SHADER_STAGE_VERTEX_BIT</span><span class="p">),</span>
    <span class="n">frag_triangle</span><span class="p">.</span><span class="n">StageCreateInfo</span><span class="p">(</span><span class="n">VK_SHADER_STAGE_FRAGMENT_BIT</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>
</div>
<p>使用的函数是：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkPipelineShaderStageCreateInfo</span> <span class="nf">StageCreateInfo</span><span class="p">(</span><span class="n">VkShaderStageFlagBits</span> <span class="n">stage</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="s">&quot;main&quot;</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">VkPipelineShaderStageCreateInfo</span><span class="p">{</span>
        <span class="n">VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO</span><span class="p">,</span><span class="c1">//sType;</span>
        <span class="k">nullptr</span><span class="p">,</span>                                            <span class="c1">//pNext;</span>
        <span class="mi">0</span><span class="p">,</span>                                                  <span class="c1">//flags;</span>
        <span class="n">stage</span><span class="p">,</span>                                              <span class="c1">//stage;</span>
        <span class="n">handle</span><span class="p">,</span>                                             <span class="c1">//module;</span>
        <span class="n">entry</span><span class="p">,</span>                                              <span class="c1">//pName;</span>
        <span class="k">nullptr</span>                                             <span class="c1">//pSpecializationInfo;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><span class="kw">struct</span> <span class="type">VkPipelineShaderStageCreateInfo</span> {</div>
<div class="line-block">
<div class="line"><span class="type">VkStructureType</span> sType;</div>
<div class="line"><span class="kw">const void</span> * pNext;</div>
<div class="line"><span class="type">VkPipelineShaderStageCreateFlags</span> flags;</div>
<div class="line"><span class="type">VkShaderStageFlagBits</span> stage; <span class="comment">//阶段</span></div>
<div class="line"><span class="type">VkShaderModule</span> module;</div>
<div class="line"><span class="kw">const char</span> * pName; <span class="comment">//主函数名称</span></div>
<div class="line"><span class="kw">const</span> <span class="type">VkSpecializationInfo</span> * pSpecializationInfo; <span class="comment">//用于特化常量，日后再说</span></div>
</div>
<div class="line">};</div>
<div class="line">特化常量的内容估计会等到延迟渲染再讲。</div>
<div class="line">于是我们第一个三角形的着色器只需填入module和主函数名称，并指定阶段即可。</div>
</div>
</div>
<div class="section" id="id10">
<h3>创建渲染通道<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">创建渲染通道的参数多到爆炸，于是我写了一个辅助类。</div>
<div class="line">在 <code class="docutils literal notranslate"><span class="pre">VKBase+.h</span></code> 中，vulkan名称空间下加入以下内容：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">graphicsPipelineCreateInfoPack</span> <span class="p">{</span>
    <span class="n">VkGraphicsPipelineCreateInfo</span> <span class="n">createInfo</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPipelineShaderStageCreateInfo</span><span class="o">&gt;</span> <span class="n">shaderStages</span><span class="p">;</span>
    <span class="c1">//Vertex Input</span>
    <span class="n">VkPipelineVertexInputStateCreateInfo</span> <span class="n">vertexInputStateCi</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkVertexInputBindingDescription</span><span class="o">&gt;</span> <span class="n">vertexInputBindings</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkVertexInputAttributeDescription</span><span class="o">&gt;</span> <span class="n">vertexInputAttributes</span><span class="p">;</span>
    <span class="c1">//Input Assembly</span>
    <span class="n">VkPipelineInputAssemblyStateCreateInfo</span> <span class="n">inputAssemblyStateCi</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO</span> <span class="p">};</span>
    <span class="c1">//Tessellation</span>
    <span class="n">VkPipelineTessellationStateCreateInfo</span> <span class="n">tessellationStateCi</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO</span> <span class="p">};</span>
    <span class="c1">//Viewport</span>
    <span class="n">VkPipelineViewportStateCreateInfo</span> <span class="n">viewportStateCi</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkViewport</span><span class="o">&gt;</span> <span class="n">viewports</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkRect2D</span><span class="o">&gt;</span> <span class="n">scissors</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">dynamicViewportCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">dynamicScissorCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">//Rasterization</span>
    <span class="n">VkPipelineRasterizationStateCreateInfo</span> <span class="n">rasterizationStateCi</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO</span> <span class="p">};</span>
    <span class="c1">//Multisample</span>
    <span class="n">VkPipelineMultisampleStateCreateInfo</span> <span class="n">multisampleStateCi</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO</span> <span class="p">};</span>
    <span class="c1">//Depth &amp; Stencil</span>
    <span class="n">VkPipelineDepthStencilStateCreateInfo</span> <span class="n">depthStencilStateCi</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO</span> <span class="p">};</span>
    <span class="c1">//Color Blend</span>
    <span class="n">VkPipelineColorBlendStateCreateInfo</span> <span class="n">colorBlendStateCi</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPipelineColorBlendAttachmentState</span><span class="o">&gt;</span> <span class="n">colorBlendAttachmentStates</span><span class="p">;</span>
    <span class="c1">//Dynamic</span>
    <span class="n">VkPipelineDynamicStateCreateInfo</span> <span class="n">dynamicStateCi</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkDynamicState</span><span class="o">&gt;</span> <span class="n">dynamicStates</span><span class="p">;</span>
    <span class="c1">//--------------------</span>
    <span class="n">graphicsPipelineCreateInfoPack</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">SetCreateInfos</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">graphicsPipelineCreateInfoPack</span><span class="p">(</span><span class="k">const</span> <span class="n">graphicsPipelineCreateInfoPack</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">createInfo</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">createInfo</span><span class="p">;</span>
        <span class="n">SetCreateInfos</span><span class="p">();</span>

        <span class="n">vertexInputStateCi</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">vertexInputStateCi</span><span class="p">;</span>
        <span class="n">inputAssemblyStateCi</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">inputAssemblyStateCi</span><span class="p">;</span>
        <span class="n">tessellationStateCi</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">tessellationStateCi</span><span class="p">;</span>
        <span class="n">viewportStateCi</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">viewportStateCi</span><span class="p">;</span>
        <span class="n">rasterizationStateCi</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">rasterizationStateCi</span><span class="p">;</span>
        <span class="n">multisampleStateCi</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">multisampleStateCi</span><span class="p">;</span>
        <span class="n">depthStencilStateCi</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">depthStencilStateCi</span><span class="p">;</span>
        <span class="n">colorBlendStateCi</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">colorBlendStateCi</span><span class="p">;</span>
        <span class="n">dynamicStateCi</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">dynamicStateCi</span><span class="p">;</span>

        <span class="n">shaderStages</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">shaderStages</span><span class="p">;</span>
        <span class="n">vertexInputBindings</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">vertexInputBindings</span><span class="p">;</span>
        <span class="n">vertexInputAttributes</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">vertexInputAttributes</span><span class="p">;</span>
        <span class="n">viewports</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">viewports</span><span class="p">;</span>
        <span class="n">scissors</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">scissors</span><span class="p">;</span>
        <span class="n">colorBlendAttachmentStates</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">colorBlendAttachmentStates</span><span class="p">;</span>
        <span class="n">dynamicStates</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">dynamicStates</span><span class="p">;</span>
        <span class="n">UpdateAllArrayAddresses</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">//Getter</span>
    <span class="k">operator</span> <span class="n">VkGraphicsPipelineCreateInfo</span><span class="o">&amp;</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">createInfo</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">//Non-const Function</span>
    <span class="kt">void</span> <span class="n">UpdateAllArrays</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">createInfo</span><span class="p">.</span><span class="n">stageCount</span> <span class="o">=</span> <span class="n">shaderStages</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vertexInputStateCi</span><span class="p">.</span><span class="n">vertexBindingDescriptionCount</span> <span class="o">=</span> <span class="n">vertexInputBindings</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vertexInputStateCi</span><span class="p">.</span><span class="n">vertexAttributeDescriptionCount</span> <span class="o">=</span> <span class="n">vertexInputAttributes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">viewportStateCi</span><span class="p">.</span><span class="n">viewportCount</span> <span class="o">=</span> <span class="n">viewports</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">viewports</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">:</span> <span class="n">dynamicViewportCount</span><span class="p">;</span>
        <span class="n">viewportStateCi</span><span class="p">.</span><span class="n">scissorCount</span> <span class="o">=</span> <span class="n">scissors</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">scissors</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">:</span> <span class="n">dynamicScissorCount</span><span class="p">;</span>
        <span class="n">colorBlendStateCi</span><span class="p">.</span><span class="n">attachmentCount</span> <span class="o">=</span> <span class="n">colorBlendAttachmentStates</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">dynamicStateCi</span><span class="p">.</span><span class="n">dynamicStateCount</span> <span class="o">=</span> <span class="n">dynamicStates</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">UpdateAllArrayAddresses</span><span class="p">();</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">SetCreateInfos</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">createInfo</span><span class="p">.</span><span class="n">pVertexInputState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vertexInputStateCi</span><span class="p">;</span>
        <span class="n">createInfo</span><span class="p">.</span><span class="n">pInputAssemblyState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inputAssemblyStateCi</span><span class="p">;</span>
        <span class="n">createInfo</span><span class="p">.</span><span class="n">pTessellationState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tessellationStateCi</span><span class="p">;</span>
        <span class="n">createInfo</span><span class="p">.</span><span class="n">pViewportState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">viewportStateCi</span><span class="p">;</span>
        <span class="n">createInfo</span><span class="p">.</span><span class="n">pRasterizationState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rasterizationStateCi</span><span class="p">;</span>
        <span class="n">createInfo</span><span class="p">.</span><span class="n">pMultisampleState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">multisampleStateCi</span><span class="p">;</span>
        <span class="n">createInfo</span><span class="p">.</span><span class="n">pDepthStencilState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">depthStencilStateCi</span><span class="p">;</span>
        <span class="n">createInfo</span><span class="p">.</span><span class="n">pColorBlendState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">colorBlendStateCi</span><span class="p">;</span>
        <span class="n">createInfo</span><span class="p">.</span><span class="n">pDynamicState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dynamicStateCi</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">UpdateAllArrayAddresses</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">createInfo</span><span class="p">.</span><span class="n">pStages</span> <span class="o">=</span> <span class="n">shaderStages</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
        <span class="n">vertexInputStateCi</span><span class="p">.</span><span class="n">pVertexBindingDescriptions</span> <span class="o">=</span> <span class="n">vertexInputBindings</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
        <span class="n">vertexInputStateCi</span><span class="p">.</span><span class="n">pVertexAttributeDescriptions</span> <span class="o">=</span> <span class="n">vertexInputAttributes</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
        <span class="n">viewportStateCi</span><span class="p">.</span><span class="n">pViewports</span> <span class="o">=</span> <span class="n">viewports</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
        <span class="n">viewportStateCi</span><span class="p">.</span><span class="n">pScissors</span> <span class="o">=</span> <span class="n">scissors</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
        <span class="n">colorBlendStateCi</span><span class="p">.</span><span class="n">pAttachments</span> <span class="o">=</span> <span class="n">colorBlendAttachmentStates</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
        <span class="n">dynamicStateCi</span><span class="p">.</span><span class="n">pDynamicStates</span> <span class="o">=</span> <span class="n">dynamicStates</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">由于结构体实在太多了，我不打算一一解释，只看下 <span class="type">VkGraphicsPipelineCreateInfo</span> ：</div>
<div class="line"><span class="kw">struct</span> <span class="type">VkGraphicsPipelineCreateInfo</span> {</div>
<div class="line-block">
<div class="line"><span class="type">VkStructureType</span> sType;</div>
<div class="line"><span class="kw">const void</span> * pNext;</div>
<div class="line"><span class="type">VkPipelineCreateFlags</span> flags;</div>
<div class="line"><span class="type">uint32_t</span> stageCount; <span class="comment">//有几个着色器阶段</span></div>
<div class="line"><span class="kw">const</span> <span class="type">VkPipelineShaderStageCreateInfo</span> * pStages; <span class="comment">//指向着色器阶段创建信息</span></div>
<div class="line"><span class="kw">const</span> <span class="type">VkPipelineVertexInputStateCreateInfo</span> * pVertexInputState; <span class="comment">//顶点输入状态</span></div>
<div class="line"><span class="kw">const</span> <span class="type">VkPipelineInputAssemblyStateCreateInfo</span> * pInputAssemblyState; <span class="comment">//输入装配状态</span></div>
<div class="line"><span class="kw">const</span> <span class="type">VkPipelineTessellationStateCreateInfo</span> * pTessellationState; <span class="comment">//细分状态</span></div>
<div class="line"><span class="kw">const</span> <span class="type">VkPipelineViewportStateCreateInfo</span> * pViewportState; <span class="comment">//视口状态</span></div>
<div class="line"><span class="kw">const</span> <span class="type">VkPipelineRasterizationStateCreateInfo</span> * pRasterizationState; <span class="comment">//栅格化状态</span></div>
<div class="line"><span class="kw">const</span> <span class="type">VkPipelineMultisampleStateCreateInfo</span> * pMultisampleState; <span class="comment">//多重采样状态</span></div>
<div class="line"><span class="kw">const</span> <span class="type">VkPipelineDepthStencilStateCreateInfo</span> * pDepthStencilState; <span class="comment">//深度模板测试状态</span></div>
<div class="line"><span class="kw">const</span> <span class="type">VkPipelineColorBlendStateCreateInfo</span> * pColorBlendState; <span class="comment">//混色状态</span></div>
<div class="line"><span class="kw">const</span> <span class="type">VkPipelineDynamicStateCreateInfo</span> * pDynamicState; <span class="comment">//动态（在命令缓冲区中可变）状态</span></div>
<div class="line"><span class="type">VkPipelineLayout</span> layout; <span class="comment">//管线布局</span></div>
<div class="line"><span class="type">VkRenderPass</span> renderPass; <span class="comment">//渲染通道</span></div>
<div class="line"><span class="type">uint32_t</span> subpass; <span class="comment">//子通道索引</span></div>
<div class="line"><span class="type">VkPipeline</span> basePipelineHandle; <span class="comment">//涉及到渲染管线派生，等到立方体贴图的章节我再讲</span></div>
<div class="line"><span class="type">int32_t</span> basePipelineIndex; <span class="comment">//同涉及到渲染管线派生</span></div>
</div>
<div class="line">};</div>
<div class="line">各个结构体的信息请自行F12查看。</div>
<div class="line">我们会在之后的教程里只写我们所需的内容，不需要的那些取0没有问题。</div>
</div>
<div class="line-block">
<div class="line"><span class="type">graphicsPipelineCreateInfoPack</span> 中的vector用于存储一些数组，将必要的参数都push进相应vector后，调用 <code class="docutils literal notranslate"><span class="pre">UpdateAllArrays</span></code> 来更新数量和数据地址。</div>
</div>
<div class="line-block">
<div class="line">于是创建管线的代码：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">Create</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">{</span>
    <span class="n">graphicsPipelineCreateInfoPack</span> <span class="n">pipelineCiPack</span><span class="p">{};</span>
    <span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">createInfo</span><span class="p">.</span><span class="n">layout</span> <span class="o">=</span> <span class="n">pipelineLayout_triangle</span><span class="p">;</span>
    <span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">createInfo</span><span class="p">.</span><span class="n">renderPass</span> <span class="o">=</span> <span class="n">easyVulkan</span><span class="o">::</span><span class="n">rpwf_screen</span><span class="p">.</span><span class="n">renderPass</span><span class="p">;</span><span class="c1">//使用我们前一节课创建的渲染通道</span>

    <span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">inputAssemblyStateCi</span><span class="p">.</span><span class="n">topology</span> <span class="o">=</span> <span class="n">VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP</span><span class="p">;</span>
    <span class="c1">//inputAssemblyStateCi.topology 指定了图元类型，常见的有：</span>
    <span class="c1">//VK_PRIMITIVE_TOPOLOGY_POINT_LIST 点列</span>
    <span class="c1">//VK_PRIMITIVE_TOPOLOGY_LINE_LIST 每两个点构成一条线，不重用顶点</span>
    <span class="c1">//VK_PRIMITIVE_TOPOLOGY_LINE_STRIP 每个点与其下一个顶点构成线，直到没有下一个顶点为止</span>
    <span class="c1">//VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST 每三个点构成一个三角形，不重用</span>
    <span class="c1">//VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP 每两个顶点与其下一个顶点构成三角形，直到没有下一个顶点为止</span>
    <span class="c1">//我们只画一个三角形，所以随你使用VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST或VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP</span>


    <span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">viewports</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">0.f</span><span class="p">,</span> <span class="kt">float</span><span class="p">(</span><span class="n">windowSize</span><span class="p">.</span><span class="n">width</span><span class="p">),</span> <span class="kt">float</span><span class="p">(</span><span class="n">windowSize</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="mf">0.f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
    <span class="c1">//viewport是视口</span>
    <span class="c1">//前四个字段的单位是像素，前两个字段表示起始点（左上为0，0），中间两个字段表示图像大小，如果是负的，会从起始点反向衍生。</span>
    <span class="c1">//最后两个字段表示深度范围，必须是在0到1之间的小数</span>
    <span class="c1">//如果你的帧缓冲带有深度附件，深度在被输出之前，会被映射到这个范围里</span>
    <span class="c1">//举例而言，Vulkan的标准化设备坐标系中深度是0到1，</span>
    <span class="c1">//如果你某个片段在着色器中的深度是0.5f，然后你设置视口深度范围为0到0.6f，那么最后被写入深度附件的数值就是0.3f</span>

    <span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">scissors</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">VkOffset2D</span><span class="p">{},</span> <span class="n">windowSize</span><span class="p">);</span>
    <span class="c1">//scissor是剪裁范围，前一组数值是起始点，后一组数值是结束点，单位是像素，结束点坐标应当大于起始点。</span>

    <span class="c1">//只有开启了多视口特性（还记得VkPhysicalDeviceFeatures么？），viewport和scissor的数量才能多于一个</span>
    <span class="c1">//如果你要经常改变剪裁和视口，你可以在动态状态中指定（之后在命令缓冲区中设置视口/剪裁），若使用动态视口或剪裁，那么上面就无需填写了。</span>

    <span class="c1">//设置背面剔除模式为剔除背面</span>
    <span class="c1">//由于默认逆时针为正面，若三角形的三个顶点在标准化设备坐标系中是顺时针（从屏幕前你的角度看过去），那么会被剔除</span>
    <span class="c1">//对于画2D，这个其实不太必要，不过先放在这里讲了。</span>
    <span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">rasterizationStateCi</span><span class="p">.</span><span class="n">cullMode</span> <span class="o">=</span> <span class="n">VK_CULL_MODE_BACK_BIT</span><span class="p">;</span>
    <span class="c1">//pipelineCiPack.rasterizationStateCi.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;//Default</span>

    <span class="c1">//不使用多重采样</span>
    <span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">multisampleStateCi</span><span class="p">.</span><span class="n">rasterizationSamples</span> <span class="o">=</span> <span class="n">VK_SAMPLE_COUNT_1_BIT</span><span class="p">;</span>

    <span class="c1">//混色状态</span>
    <span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">colorBlendAttachmentStates</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
        <span class="nb">true</span><span class="p">,</span><span class="c1">//开启混色</span>
        <span class="c1">//源颜色混合因子，            ，目标颜色颜色混合因子           ，颜色混合运算方式</span>
        <span class="n">VK_BLEND_FACTOR_SRC_ALPHA</span><span class="p">,</span> <span class="n">VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA</span><span class="p">,</span> <span class="n">VK_BLEND_OP_ADD</span><span class="p">,</span>
        <span class="c1">//类似上一条，但是是透明度</span>
        <span class="n">VK_BLEND_FACTOR_ONE</span><span class="p">,</span> <span class="n">VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA</span><span class="p">,</span> <span class="n">VK_BLEND_OP_ADD</span><span class="p">,</span>
        <span class="mb">0b1111</span><span class="c1">//colorWriteMask，这里是RGB四个通道全部写入</span>
    <span class="p">);</span>
    <span class="c1">//来解读一下：</span>
    <span class="c1">//目标是指已在颜色附件中的片段，而源是片段着色器中输出的片段</span>
    <span class="c1">//我上面所写的是对于直接写入屏幕缓冲（即交换链中的图像），最一般的混色方式</span>
    <span class="c1">//颜色计算：</span>
    <span class="c1">//源颜色 * 源颜色混色因子 + 目标颜色 * 目标颜色混色因子</span>
    <span class="c1">//= RGBsrc * Asrc + RGBdst * (1- Asrc)</span>
    <span class="c1">//你可以这么验算其正确性：若RGBsrc和RGBdst一致，则最终颜色不变</span>
    <span class="c1">//透明度计算：</span>
    <span class="c1">//源透明度 * 源透明度混色因子 + 目标透明度（屏幕缓冲的话是1） * 目标透明度混色因子</span>
    <span class="c1">//= Asrc * 1 + 1 * (1 - Asrc) = 1</span>

    <span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">UpdateAllArrays</span><span class="p">();</span>
    <span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">createInfo</span><span class="p">.</span><span class="n">stageCount</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">createInfo</span><span class="p">.</span><span class="n">pStages</span> <span class="o">=</span> <span class="n">shaderStageCreateInfos_triangle</span><span class="p">;</span>
    <span class="n">pipeline_triangle</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">pipelineCiPack</span><span class="p">.</span><span class="n">createInfo</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">auto</span> <span class="n">Destroy</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">{</span>
    <span class="n">pipeline_triangle</span><span class="p">.</span><span class="o">~</span><span class="n">pipeline</span><span class="p">();</span>
<span class="p">};</span>
<span class="n">graphicsBase</span><span class="o">::</span><span class="n">Base</span><span class="p">().</span><span class="n">PushCallback_CreateSwapchain</span><span class="p">(</span><span class="n">Create</span><span class="p">);</span>
<span class="n">graphicsBase</span><span class="o">::</span><span class="n">Base</span><span class="p">().</span><span class="n">PushCallback_DestroySwapchain</span><span class="p">(</span><span class="n">Destroy</span><span class="p">);</span>
<span class="n">Create</span><span class="p">();</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">之后我们在主函数中，在 <code class="docutils literal notranslate"><span class="pre">easyVulkan::CreateRpwf_Screen()</span></code> 后执行 <code class="docutils literal notranslate"><span class="pre">CreateLayout</span></code> 和 <code class="docutils literal notranslate"><span class="pre">CreatePipeline</span></code></div>
</div>
</div>
</div>
<div class="section" id="id11">
<h2>绘制三角形<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">我们上一节课中已经录制过命令缓冲区了，这节课要做的就是在渲染通道开始后加入绘制命令：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">vulkan</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">InitializeWindow</span><span class="p">({</span> <span class="mi">1280</span><span class="p">,</span><span class="mi">720</span> <span class="p">}))</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="n">easyVulkan</span><span class="o">::</span><span class="n">CreateRpwf_Screen</span><span class="p">();</span>
    <span class="n">CreateLayout</span><span class="p">();</span>
    <span class="n">CreatePipeline</span><span class="p">();</span>

    <span class="c1">//Synchronization Object</span>
    <span class="n">semaphore</span> <span class="n">semaphore_imageIsAvailable</span><span class="p">;</span>
    <span class="n">semaphore</span> <span class="n">semaphore_renderingIsOver</span><span class="p">;</span>
    <span class="n">fence</span> <span class="n">fence</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="c1">//Command Object</span>
    <span class="n">commandPool</span> <span class="n">commandPool</span><span class="p">(</span><span class="n">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</span><span class="p">,</span> <span class="n">graphicsBase</span><span class="o">::</span><span class="n">Base</span><span class="p">().</span><span class="n">QueueFamilyIndex_Graphics</span><span class="p">());</span>
    <span class="n">commandBuffer</span> <span class="n">commandBuffer_graphics</span><span class="p">;</span>
    <span class="n">commandPool</span><span class="p">.</span><span class="n">AllocateCommandBuffers</span><span class="p">((</span><span class="n">VkCommandBuffer</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">commandBuffer_graphics</span><span class="p">);</span>

    <span class="c1">//Clear Color</span>
    <span class="n">VkClearValue</span> <span class="n">clearColor</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.f</span><span class="p">,</span> <span class="mf">0.f</span><span class="p">,</span> <span class="mf">0.f</span><span class="p">,</span> <span class="mf">1.f</span> <span class="p">}</span> <span class="p">};</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">pWindow</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">TitleFps</span><span class="p">();</span>
        <span class="n">graphicsBase</span><span class="o">::</span><span class="n">Base</span><span class="p">().</span><span class="n">SwapImage</span><span class="p">(</span><span class="n">semaphore_imageIsAvailable</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">graphicsBase</span><span class="o">::</span><span class="n">Base</span><span class="p">().</span><span class="n">CurrentImageIndex</span><span class="p">();</span>
        <span class="n">fence</span><span class="p">.</span><span class="n">WaitAndReset</span><span class="p">();</span>

        <span class="n">commandBuffer_graphics</span><span class="p">.</span><span class="n">Begin</span><span class="p">(</span><span class="n">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</span><span class="p">);</span>
        <span class="n">easyVulkan</span><span class="o">::</span><span class="n">rpwf_screen</span><span class="p">.</span><span class="n">renderPass</span><span class="p">.</span><span class="n">CmdBegin</span><span class="p">(</span><span class="n">commandBuffer_graphics</span><span class="p">,</span> <span class="n">easyVulkan</span><span class="o">::</span><span class="n">rpwf_screen</span><span class="p">.</span><span class="n">framebuffers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">clearColor</span><span class="p">);</span>

        <span class="c1">//首先绑定渲染管线</span>
        <span class="n">vkCmdBindPipeline</span><span class="p">(</span><span class="n">commandBuffer_graphics</span><span class="p">,</span> <span class="n">VK_PIPELINE_BIND_POINT_GRAPHICS</span><span class="p">,</span> <span class="n">pipeline_triangle</span><span class="p">);</span>
        <span class="c1">//然后绘制，参数2~5分别是：顶点个数，实例个数，初始顶点编号，初始实例编号</span>
        <span class="c1">//我们绘制三角形，所以会有三个顶点</span>
        <span class="c1">//实例化日后等到贴图数组再讲，眼下只绘制一个实例</span>
        <span class="n">vkCmdDraw</span><span class="p">(</span><span class="n">commandBuffer_graphics</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="n">easyVulkan</span><span class="o">::</span><span class="n">rpwf_screen</span><span class="p">.</span><span class="n">renderPass</span><span class="p">.</span><span class="n">CmdEnd</span><span class="p">(</span><span class="n">commandBuffer_graphics</span><span class="p">);</span>
        <span class="n">commandBuffer_graphics</span><span class="p">.</span><span class="n">End</span><span class="p">();</span>
        <span class="n">graphicsBase</span><span class="o">::</span><span class="n">Base</span><span class="p">().</span><span class="n">SubmitGraphicsCommandBuffer</span><span class="p">(</span><span class="n">commandBuffer_graphics</span><span class="p">,</span> <span class="n">semaphore_imageIsAvailable</span><span class="p">,</span> <span class="n">semaphore_renderingIsOver</span><span class="p">,</span> <span class="n">fence</span><span class="p">);</span>

        <span class="n">graphicsBase</span><span class="o">::</span><span class="n">Base</span><span class="p">().</span><span class="n">PresentImage</span><span class="p">(</span><span class="n">semaphore_renderingIsOver</span><span class="p">);</span>
        <span class="n">glfwPollEvents</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">TerminateWindow</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">执行程序，你应该会看到一个全红的画面中有个蓝色的三角形。</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Ch2-4%20%E5%8D%B3%E6%97%B6%E5%B8%A7%E4%B8%8E%E9%98%9F%E5%88%97%E6%97%8F%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB.html" class="btn btn-neutral float-right" title="Ch2-4 即时帧与队列族所有权转移" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Ch2-2%20Rendering%20Loop.html" class="btn btn-neutral float-left" title="Ch2-2 Rendering Loop" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Qiao Wu.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>