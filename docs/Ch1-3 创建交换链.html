

<!DOCTYPE html>
<html class="writer-html5" lang="chs" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Ch1-3 创建交换链 &mdash; EasyVulkan</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Ch1-4 承前启后" href="Ch1-4%20%E6%89%BF%E5%89%8D%E5%90%AF%E5%90%8E.html" />
    <link rel="prev" title="Ch1-2 创建Vk实例与逻辑设备" href="Ch1-2%20%E5%88%9B%E5%BB%BAVk%E5%AE%9E%E4%BE%8B%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> EasyVulkan
          

          
            
            <img src="_static/logo1.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">第一章 从零到交换链</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Ch1-0%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html">Ch1-0 准备工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-1%20%E5%88%9B%E5%BB%BAGLFW%E7%AA%97%E5%8F%A3.html">Ch1-1 创建GLFW窗口</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-2%20%E5%88%9B%E5%BB%BAVk%E5%AE%9E%E4%BE%8B%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87.html">Ch1-2 创建Vk实例与逻辑设备</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Ch1-3 创建交换链</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">创建交换链</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#surface-capabilities">Surface Capabilities相关的参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#surface-format">Surface Format相关的参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#surface-present-mode">Surface Present Mode相关的参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">剩余的参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">创建交换链</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#imageimage-view">获取Image并创建Image View</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">获取交换链图像</a></li>
<li class="toctree-l3"><a class="reference internal" href="#image-view">创建Image View</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">重建交换链</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">设置相关回调及销毁对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">试运行</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-4%20%E6%89%BF%E5%89%8D%E5%90%AF%E5%90%8E.html">Ch1-4 承前启后</a></li>
</ul>
<p class="caption"><span class="caption-text">第二章 基础绘制</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch2-1%20%E5%88%9B%E5%BB%BA%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93.html">Ch2-1 创建渲染通道</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch2-2%20Rendering%20Loop.html">Ch2-2 Rendering Loop</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch2-3%20%E5%A4%A9%E5%93%AA%EF%BC%8C%E6%98%AF%E4%B8%89%E8%A7%92%E5%BD%A2.html">Ch2-3 天哪，是三角形</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch2-4%20%E5%8D%B3%E6%97%B6%E5%B8%A7%E4%B8%8E%E9%98%9F%E5%88%97%E6%97%8F%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB.html">Ch2-4 即时帧与队列族所有权转移</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EasyVulkan</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Ch1-3 创建交换链</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="ch1-3">
<h1>Ch1-3 创建交换链<a class="headerlink" href="#ch1-3" title="Permalink to this headline">¶</a></h1>
<div class="line-block">
<div class="line">交换链由数张图像构成，当我们将其中某张图像呈现在屏幕上时，其它图像可用于渲染，等新图像渲染完后与屏幕上的图像进行交换。</div>
</div>
<div class="section" id="id1">
<h2>创建交换链<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">在 <span class="type">graphicsBase</span> 前添加以下内容：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//Constexpr</span>
<span class="cp">#ifdef GAMMA_CORRECTION</span>
    <span class="k">constexpr</span> <span class="n">VkFormat</span> <span class="n">format_rgba8</span> <span class="o">=</span> <span class="n">VK_FORMAT_R8G8B8A8_SRGB</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">VkFormat</span> <span class="n">format_r8</span> <span class="o">=</span> <span class="n">VK_FORMAT_R8_SRGB</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="k">constexpr</span> <span class="n">VkFormat</span> <span class="n">format_rgba8</span> <span class="o">=</span> <span class="n">VK_FORMAT_R8G8B8A8_UNORM</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">VkFormat</span> <span class="n">format_r8</span> <span class="o">=</span> <span class="n">VK_FORMAT_R8_UNORM</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="c1">//Defalut Value</span>
<span class="k">constexpr</span> <span class="n">VkExtent2D</span> <span class="n">defaultWindowSize</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span> <span class="p">};</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><span class="type">VkFormat</span> 类型是种枚举，表达Vulkan中的格式（用于图像或顶点）。其中用RGBA表示有几个分量，RGBA后面的数字表示位数，R8表示R通道有8位即1字节，UNORM的U表示无符号，NORM表示标准化，即在shader中使用时会被化为0到1之间的小数。SRGB则是一种特殊的格式，如果要做Gamma校正，你的交换链以及之后贴图的图像格式都需要是SRGB格式。</div>
<div class="line">除了UNORM以外，常见的格式后缀还有SNORM、SINT、UINT、SFLOAT，S表示有符号U表示无符号，那么意思自然不必多说了，比较让人迷惑的是SSCALED和USCALED，SCALED表示使用整数存储但在着色器中读取时会被转为浮点数，数值不变。</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">format_rgba8</span></code> 用于我们的交换链以及一般的图像格式，而 <code class="docutils literal notranslate"><span class="pre">format_r8</span></code> 用于单色图像格式，比如单色文字的贴图。</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">defaultWindowSize</span></code> 是默认窗口大小，数值随你喜欢，仅仅用于所创建的surface没有合适大小的时候（就用GLFW创建的窗口而言，这种事不会发生。）</div>
</div>
<div class="line-block">
<div class="line">在 <span class="type">graphicsBase</span> 中添加以下内容：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>    <span class="n">VkSwapchainKHR</span> <span class="n">swapchain</span> <span class="o">=</span> <span class="n">VK_NULL_HANDLE</span><span class="p">;</span>
    <span class="n">VkSwapchainCreateInfoKHR</span> <span class="n">swapchainCreateInfo</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="kt">void</span> <span class="nf">CreateSwapchain_Internal</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/*待填充*/</span> <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">VkSwapchainKHR</span> <span class="n">Swapchain</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">swapchain</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">VkSwapchainCreateInfoKHR</span><span class="o">&amp;</span> <span class="n">SwapchainCreateInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">swapchainCreateInfo</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">CreateSwapchain</span><span class="p">(</span><span class="kt">bool</span> <span class="n">limit_framerate</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*待填充*/</span> <span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><span class="type">swapchainCreateInfo</span> 需要被保存下来，因为你之后可能会想要重建交换链。</div>
<div class="line">函数 <code class="docutils literal notranslate"><span class="pre">CreateSwapchain_Internal</span></code> 用于书写创建交换链与重建交换链的代码的共有部分。</div>
</div>
<div class="line-block">
<div class="line">如何创建一个交换链？你应该明白Vulkan的套路了，没错，又是填写某种结构体。</div>
<div class="line">来看看用于创建 <span class="type">VkSwapchainKHR</span> 的 <span class="type">VkSwapchainCreateInfoKHR</span> 结构体：</div>
<div class="line"><span class="kw">struct</span> <span class="type">VkSwapchainCreateInfoKHR</span> {</div>
<div class="line-block">
<div class="line"><span class="type">VkStructureType</span> sType; <span class="comment">//VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR</span></div>
<div class="line"><span class="kw">const void</span> *  pNext;</div>
<div class="line"><span class="type">VkSwapchainCreateFlagsKHR</span> flags;</div>
<div class="line"><span class="type">VkSurfaceKHR</span> surface; <span class="comment">//填入之前所创建的surface</span></div>
<div class="line"><span class="type">uint32_t</span> minImageCount; <span class="comment">//交换链中图片的最少数量</span></div>
<div class="line"><span class="type">VkFormat</span> imageFormat; <span class="comment">//交换链中图像的格式</span></div>
<div class="line"><span class="type">VkColorSpaceKHR</span> imageColorSpace; <span class="comment">//交换链中图像的色彩空间</span></div>
<div class="line"><span class="type">VkExtent2D</span> imageExtent; <span class="comment">//图像的大小</span></div>
<div class="line"><span class="type">uint32_t</span> imageArrayLayers; <span class="comment">//对于多视口或3D设备，需要提供一个视口数，对于普通的2D显示设备，该值为1</span></div>
<div class="line"><span class="type">VkImageUsageFlags</span> imageUsage; <span class="comment">//图像的用途</span></div>
<div class="line"><span class="type">VkSharingMode</span> imageSharingMode; <span class="comment">//图像的分享模式</span></div>
<div class="line"><span class="type">uint32_t</span> queueFamilyIndexCount; <span class="comment">//如果在上一字段中选择了VK_SHARING_MODE_CONCURRENT，这里需指定将会访问交换链图像的队列族总数</span></div>
<div class="line"><span class="kw">const</span> <span class="type">uint32_t</span> * pQueueFamilyIndices; <span class="comment">//继续上一条，以及具体的队列族索引</span></div>
<div class="line"><span class="type">VkSurfaceTransformFlagBitsKHR</span> preTransform; <span class="comment">//对交换链图像的变换，比如旋转90度等</span></div>
<div class="line"><span class="type">VkCompositeAlphaFlagBitsKHR</span> compositeAlpha; <span class="comment">//如何处理交换链图像的透明度</span></div>
<div class="line"><span class="type">VkPresentModeKHR</span> presentMode; <span class="comment">//呈现方式</span></div>
<div class="line"><span class="type">VkBool32</span> clipped; <span class="comment">//是否允许舍弃掉交换链图像应有但窗口中不会显示的像素</span></div>
<div class="line"><span class="type">VkSwapchainKHR</span> oldSwapchain; <span class="comment">//旧的交换链，在重建交换链时填入</span></div>
</div>
<div class="line">};</div>
</div>
<div class="line-block">
<div class="line">我们会在填充 <code class="docutils literal notranslate"><span class="pre">CreateSwapchain</span></code> 的过程中取得以上参数。</div>
</div>
<div class="section" id="surface-capabilities">
<h3>Surface Capabilities相关的参数<a class="headerlink" href="#surface-capabilities" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">交换链与surface相关，于是先来填写 <span class="type">VkSwapchainCreateInfoKHR</span> 中与 <span class="type">VkSurfaceCapabilitiesKHR</span> 有关的参数。</div>
<div class="line">获取 <span class="type">VkSurfaceCapabilitiesKHR</span> 结构体：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkSurfaceCapabilitiesKHR</span> <span class="n">surfaceCapabilities</span><span class="p">{};</span>
<span class="k">if</span> <span class="p">(</span><span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span><span class="p">(</span><span class="n">physicalDevice</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">surfaceCapabilities</span><span class="p">))</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to get physical device surface capabilities!</span><span class="se">\n</span><span class="s">Error code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">,</span>
    <span class="n">abort</span><span class="p">();</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">对于 <code class="docutils literal notranslate"><span class="pre">minImageCount</span></code> ，先获得 <code class="docutils literal notranslate"><span class="pre">surfaceCapabilities</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">minImageCount</span></code> ，然后如果 <code class="docutils literal notranslate"><span class="pre">surfaceCapabilities</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">maxImageCount</span></code> 比 <code class="docutils literal notranslate"><span class="pre">minImageCount</span></code> 大，那么就再多一张：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">minImageCount</span> <span class="o">=</span> <span class="n">surfaceCapabilities</span><span class="p">.</span><span class="n">minImageCount</span> <span class="o">+</span> <span class="p">(</span><span class="n">surfaceCapabilities</span><span class="p">.</span><span class="n">maxImageCount</span> <span class="o">&gt;</span> <span class="n">surfaceCapabilities</span><span class="p">.</span><span class="n">minImageCount</span><span class="p">);</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">一般 <code class="docutils literal notranslate"><span class="pre">surfaceCapabilities.minImageCount</span></code> 会是2，多一张图像可以实现三重缓冲，防止二重缓冲可能带来的阻塞。</div>
</div>
<div class="line-block">
<div class="line">然后是 <code class="docutils literal notranslate"><span class="pre">imageExtent</span></code> ：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">imageExtent</span> <span class="o">=</span>
    <span class="n">surfaceCapabilities</span><span class="p">.</span><span class="n">currentExtent</span><span class="p">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">-1</span> <span class="o">?</span>
    <span class="n">VkExtent2D</span><span class="p">{</span>
        <span class="n">glm</span><span class="o">::</span><span class="n">clamp</span><span class="p">(</span><span class="n">defaultWindowSize</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">surfaceCapabilities</span><span class="p">.</span><span class="n">minImageExtent</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">surfaceCapabilities</span><span class="p">.</span><span class="n">maxImageExtent</span><span class="p">.</span><span class="n">width</span><span class="p">),</span>
        <span class="n">glm</span><span class="o">::</span><span class="n">clamp</span><span class="p">(</span><span class="n">defaultWindowSize</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">surfaceCapabilities</span><span class="p">.</span><span class="n">minImageExtent</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">surfaceCapabilities</span><span class="p">.</span><span class="n">maxImageExtent</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="p">}</span> <span class="o">:</span>
    <span class="n">surfaceCapabilities</span><span class="p">.</span><span class="n">currentExtent</span><span class="p">;</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">这里我用了三项表达式。</div>
<div class="line">-1是个特殊值，若当surface尺寸的长或宽为-1，说明surface的尺寸为缺省，并将由交换链中图像的尺寸决定。</div>
<div class="line">若当前surface尺寸非缺省，我们直接使用当前surface的尺寸，否则我们用 <code class="docutils literal notranslate"><span class="pre">glm::clamp</span></code> 将之前所写的默认窗口大小约束到surafce所容许的最大和最小尺寸之间。</div>
</div>
<div class="line-block">
<div class="line">最后一个跟有关的数值是 <code class="docutils literal notranslate"><span class="pre">imageUsage</span></code> ：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">imageUsage</span> <span class="o">=</span> <span class="n">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">surfaceCapabilities</span><span class="p">.</span><span class="n">supportedUsageFlags</span> <span class="o">&amp;</span> <span class="n">VK_IMAGE_USAGE_TRANSFER_DST_BIT</span><span class="p">)</span>
    <span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">imageUsage</span> <span class="o">|=</span> <span class="n">VK_IMAGE_USAGE_TRANSFER_DST_BIT</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Warning: VK_IMAGE_USAGE_TRANSFER_DST_BIT isn&#39;t supported!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">交换链中的图像肯定得支持作为颜色附件（COLOR_ATTACHMENT），同时最好是能够作为数据转移的目标（TRANSFER_DST），这样我们就可以在渲染通道之外实现清屏 —— 尽管这通常不太必要。</div>
</div>
</div>
<div class="section" id="surface-format">
<h3>Surface Format相关的参数<a class="headerlink" href="#surface-format" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">首先取得Surface Format：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">surfaceFormatCount</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkGetPhysicalDeviceSurfaceFormatsKHR</span><span class="p">(</span><span class="n">physicalDevice</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">surfaceFormatCount</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">))</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to get the count of surface formats!</span><span class="se">\n</span><span class="s">Error code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">,</span>
    <span class="n">abort</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">surfaceFormatCount</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to find any supported surface format!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="n">abort</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkSurfaceFormatKHR</span><span class="o">&gt;</span> <span class="n">surfaceFormats</span><span class="p">(</span><span class="n">surfaceFormatCount</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkGetPhysicalDeviceSurfaceFormatsKHR</span><span class="p">(</span><span class="n">physicalDevice</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">surfaceFormatCount</span><span class="p">,</span> <span class="n">surfaceFormats</span><span class="p">.</span><span class="n">data</span><span class="p">()))</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to get surface formats!</span><span class="se">\n</span><span class="s">Error code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">,</span>
    <span class="n">abort</span><span class="p">();</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">为交换链选择合适的格式前，先来定义我们所期望选择的格式类型：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef GAMMA_CORRECTION</span>
    <span class="k">constexpr</span> <span class="n">VkFormat</span> <span class="n">requiredSurfaceFormats</span><span class="p">[]{</span> <span class="n">VK_FORMAT_R8G8B8A8_SRGB</span><span class="p">,</span> <span class="n">VK_FORMAT_B8G8R8A8_SRGB</span> <span class="p">};</span>
<span class="cp">#else</span>
    <span class="k">constexpr</span> <span class="n">VkFormat</span> <span class="n">requiredSurfaceFormats</span><span class="p">[]{</span> <span class="n">VK_FORMAT_R8G8B8A8_UNORM</span><span class="p">,</span> <span class="n">VK_FORMAT_B8G8R8A8_UNORM</span> <span class="p">};</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">这里还是为了Gamma校正做了个 <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code> ，以及到数组中各有两个元素 —— 分别是RGBA排列以及BGRA排列，这是因为有些显卡可能不支持RGBA排列且是SRGB或UNORM的surafce格式。</div>
<div class="line">可以放心的是，无论最终我们选择哪种排列，都不会对我们之后的渲染造成影响，不需要额外的代码来应对什么差别。</div>
<div class="line">选择合适的格式：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkSurfaceFormatKHR</span> <span class="n">selectedSurfaceFormat</span><span class="p">{};</span>
<span class="c1">//如果先前所取得的surface格式中只有一个元素且为VK_FORMAT_UNDEFINED，那么我们可以自由选择任何格式。</span>
<span class="k">if</span> <span class="p">(</span><span class="n">surfaceFormats</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
    <span class="n">surfaceFormats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">format</span> <span class="o">==</span> <span class="n">VK_FORMAT_UNDEFINED</span><span class="p">)</span>
    <span class="n">selectedSurfaceFormat</span> <span class="o">=</span> <span class="p">{</span> <span class="n">requiredSurfaceFormats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</span> <span class="p">};</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">surfaceFormats</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//双循环遍历比较，若先前所取得的surface格式中有与我们所期望的格式一致，且色彩空间为VK_COLOR_SPACE_SRGB_NONLINEAR_KHR的，就break掉内层循环。</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">size</span><span class="p">(</span><span class="n">requiredSurfaceFormats</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">surfaceFormats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">format</span> <span class="o">==</span> <span class="n">requiredSurfaceFormats</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
                <span class="n">surfaceFormats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">colorSpace</span> <span class="o">==</span> <span class="n">VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">selectedSurfaceFormat</span> <span class="o">=</span> <span class="p">{</span> <span class="n">requiredSurfaceFormats</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</span> <span class="p">};</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="c1">//通过验证selectedSurfaceFormat是否仍旧是VK_FORMAT_UNDEFINED（即默认值0），break掉外层循环</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">selectedSurfaceFormat</span><span class="p">.</span><span class="n">format</span> <span class="o">!=</span> <span class="n">VK_FORMAT_UNDEFINED</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//若上面的代码没能找出合适的格式，妥协选择所取得的surface格式中的第一个元素，并抛出警告。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">selectedSurfaceFormat</span><span class="p">.</span><span class="n">format</span> <span class="o">==</span> <span class="n">VK_FORMAT_UNDEFINED</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">selectedSurfaceFormat</span> <span class="o">=</span> <span class="n">surfaceFormats</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Warning: Failed to select the required surface format!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">注意色彩空间无论是否开启Gamma校正都应该是VK_COLOR_SPACE_SRGB_NONLINEAR_KHR。</div>
</div>
</div>
<div class="section" id="surface-present-mode">
<h3>Surface Present Mode相关的参数<a class="headerlink" href="#surface-present-mode" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">取得Surface Present Mode：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">surfacePresentModeCount</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkGetPhysicalDeviceSurfacePresentModesKHR</span><span class="p">(</span><span class="n">physicalDevice</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">surfacePresentModeCount</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">))</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to get the count of surface present modes!</span><span class="se">\n</span><span class="s">Error code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">,</span>
    <span class="n">abort</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">surfacePresentModeCount</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to find any surface present mode!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="n">abort</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPresentModeKHR</span><span class="o">&gt;</span> <span class="n">surfacePresentModes</span><span class="p">(</span><span class="n">surfacePresentModeCount</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkGetPhysicalDeviceSurfacePresentModesKHR</span><span class="p">(</span><span class="n">physicalDevice</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">surfacePresentModeCount</span><span class="p">,</span> <span class="n">surfacePresentModes</span><span class="p">.</span><span class="n">data</span><span class="p">()))</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to get surface present modes!</span><span class="se">\n</span><span class="s">Error code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">,</span>
    <span class="n">abort</span><span class="p">();</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">选择合适的呈现模式：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//如果限制帧率与屏幕刷新率一致，默认使用FIFO</span>
<span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">presentMode</span> <span class="o">=</span> <span class="n">VK_PRESENT_MODE_FIFO_KHR</span><span class="p">;</span>
<span class="c1">//若不限制帧率，遍历所取得的呈现模式，寻找MAILBOX模式</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">limit_framerate</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">surfacePresentModeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">surfacePresentModes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">VK_PRESENT_MODE_MAILBOX_KHR</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">presentMode</span> <span class="o">=</span> <span class="n">VK_PRESENT_MODE_MAILBOX_KHR</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">简要讲解一下呈现模式：</div>
</div>
<div class="line-block">
<div class="line">不使用扩展的话，一共有四种可选的呈现模式：</div>
</div>
<blockquote>
<div><ul class="simple">
<li><p>VK_PRESENT_MODE_IMMEDIATE_KHR</p></li>
<li><p>VK_PRESENT_MODE_MAILBOX_KHR</p></li>
<li><p>VK_PRESENT_MODE_FIFO_KHR</p></li>
<li><p>VK_PRESENT_MODE_FIFO_RELAXED_KHR</p></li>
</ul>
</div></blockquote>
<div class="line-block">
<div class="line">VK_PRESENT_MODE_IMMEDIATE_KHR表示立即模式，该模式下不限制帧率且帧率在所有模式中是最高的。该模式不等待垂直同步信号，一旦图片渲染完，用于呈现的图像就会被立刻替换掉。</div>
<div class="line">（配图来源于英特尔的API without Secrets系列教程）</div>
</div>
<img alt="https://software.intel.com/content/dam/develop/external/us/en/images/api-vulkan-part-2-graphic-1-623623.jpg" src="https://software.intel.com/content/dam/develop/external/us/en/images/api-vulkan-part-2-graphic-1-623623.jpg" />
<div class="line-block">
<div class="line">VK_PRESENT_MODE_FIFO_KHR表示先入先出模式，限制帧率与屏幕刷新率一致，这种模式是必定支持的。如下图所示，图像被推送进一个用于呈现的队列，然后等待垂直同步信号，按顺序被推出队列，呈现到屏幕上，所以叫先入先出：</div>
</div>
<img alt="https://software.intel.com/content/dam/develop/external/us/en/images/api-vulkan-part-2-graphic-2-623623.jpg" src="https://software.intel.com/content/dam/develop/external/us/en/images/api-vulkan-part-2-graphic-2-623623.jpg" />
<div class="line-block">
<div class="line">VK_PRESENT_MODE_FIFO_RELAXED_KHR同VK_PRESENT_MODE_FIFO_KHR的差别在于，若图像的停留时间长于一个刷新间隔，图像可能在下一个个垂直同步信号到来前就被释放掉 —— 这在帧率较低时可能会导致画面撕裂。</div>
</div>
<div class="line-block">
<div class="line">VK_PRESENT_MODE_MAILBOX_KHR是一种类似于三重缓冲的模式。它的呈现队列中只容纳一个元素，在等待垂直同步信号期间若有新的图像入队，那么旧的图像会不经过呈现直接出队（即出队不需要等待垂直同步信号，因此不限制帧率），出现在屏幕上的总会是最新的图像。</div>
</div>
<img alt="https://software.intel.com/content/dam/develop/external/us/en/images/api-vulkan-part-2-graphic-3-623623.jpg" src="https://software.intel.com/content/dam/develop/external/us/en/images/api-vulkan-part-2-graphic-3-623623.jpg" />
<div class="line-block">
<div class="line">其中VK_PRESENT_MODE_IMMEDIATE_KHR和VK_PRESENT_MODE_FIFO_RELAXED_KHR可能导致画面撕裂。所以我们在不需要限制帧率时选择VK_PRESENT_MODE_MAILBOX_KHR，需要限制帧率时选择VK_PRESENT_MODE_FIFO_KHR。</div>
</div>
<div class="line-block">
<div class="line">（这个所谓的帧率指的是单位时间里渲染图像的次数，单位时间内实际呈现在屏幕上的图像数量同显示器刷新频率一致。）</div>
</div>
</div>
<div class="section" id="id2">
<h3>剩余的参数<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR</span><span class="p">;</span>
<span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">surface</span> <span class="o">=</span> <span class="n">surface</span><span class="p">;</span>
<span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">imageArrayLayers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//用于普通显示器的单个窗口，所以是1</span>
<span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">imageSharingMode</span> <span class="o">=</span> <span class="n">VK_SHARING_MODE_EXCLUSIVE</span><span class="p">;</span>
<span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">preTransform</span> <span class="o">=</span> <span class="n">VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR</span><span class="p">;</span><span class="c1">//不需要任何变换</span>
<span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">compositeAlpha</span> <span class="o">=</span> <span class="n">VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</span><span class="p">;</span>
<span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">clipped</span> <span class="o">=</span> <span class="n">VK_TRUE</span><span class="p">;</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">对于 <code class="docutils literal notranslate"><span class="pre">imageSharingMode</span></code> ，如果选择VK_SHARING_MODE_CONCURRENT，可以少做一些同步措施，但性能上可能无法达到最佳，因此选择VK_SHARING_MODE_EXCLUSIVE。</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">compositeAlpha</span></code> 使用VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR表示不透明，图像在被呈现时，会丢失透明度 —— 这通常是我们所期望的选项。</div>
<div class="line">如果你要选择其他的 <code class="docutils literal notranslate"><span class="pre">imageSharingMode</span></code> 或 <code class="docutils literal notranslate"><span class="pre">compositeAlpha</span></code> ，你应该用位与对Surface Capabilities中的相关参数进行检查。就GLFW提供的surface而言，VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR是 <code class="docutils literal notranslate"><span class="pre">compositeAlpha</span></code> 的唯一选项。</div>
</div>
</div>
<div class="section" id="id3">
<h3>创建交换链<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">填充 <code class="docutils literal notranslate"><span class="pre">CreateSwapchain_Internal</span></code> ：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkCreateSwapchainKHR</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">swapchainCreateInfo</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">swapchain</span><span class="p">))</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to create a swapchain!</span><span class="se">\n</span><span class="s">Error code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">,</span>
    <span class="n">abort</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="imageimage-view">
<h2>获取Image并创建Image View<a class="headerlink" href="#imageimage-view" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">在 <span class="type">graphicsBase</span> 中添加以下内容：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkImage</span><span class="o">&gt;</span> <span class="n">swapchainImages</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkImageView</span><span class="o">&gt;</span> <span class="n">swapchainImageViews</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">VkImage</span> <span class="n">SwapchainImage</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">swapchainImages</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span>
        <span class="n">VkImageView</span> <span class="n">SwapchainImageView</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">swapchainImageViews</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span>
        <span class="kt">size_t</span> <span class="n">SwapchainImageCount</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">swapchainImages</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">关于 <span class="type">VkImage</span> 和 <span class="type">VkImageView</span> 的具体介绍放在了下节课，你可以先去读了再回来。</div>
<div class="line">或者你可以先不要在意这俩具体是啥，image听着还算比较顾名思义，而image view，简单地讲，它定义了图像在着色器中的使用方式。</div>
<div class="line">我们需要创建image view，之后将其用于创建帧缓冲 —— 又是一个会在下节课讲解的概念。</div>
</div>
<div class="section" id="id4">
<h3>获取交换链图像<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">来接着填充 <code class="docutils literal notranslate"><span class="pre">CreateSwapchain_Internal</span></code> ，获取图像的方式仍旧是老一套的二次调用：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">swapchainImageCount</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkGetSwapchainImagesKHR</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">swapchain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">swapchainImageCount</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">))</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to get the count of swapchain images!</span><span class="se">\n</span><span class="s">Error code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">,</span>
    <span class="n">abort</span><span class="p">();</span>
<span class="n">swapchainImages</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">swapchainImageCount</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkGetSwapchainImagesKHR</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">swapchain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">swapchainImageCount</span><span class="p">,</span> <span class="n">swapchainImages</span><span class="p">.</span><span class="n">data</span><span class="p">()))</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to get swapchain images!</span><span class="se">\n</span><span class="s">Error code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">,</span>
    <span class="n">abort</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="image-view">
<h3>创建Image View<a class="headerlink" href="#image-view" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">swapchainImageViews</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">swapchainImageCount</span><span class="p">);</span>
<span class="n">VkImageViewCreateInfo</span> <span class="n">imageViewCreateInfo</span><span class="p">{};</span>
<span class="n">imageViewCreateInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO</span><span class="p">;</span>
<span class="n">imageViewCreateInfo</span><span class="p">.</span><span class="n">viewType</span> <span class="o">=</span> <span class="n">VK_IMAGE_VIEW_TYPE_2D</span><span class="p">;</span>
<span class="n">imageViewCreateInfo</span><span class="p">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">imageFormat</span><span class="p">;</span>
<span class="n">imageViewCreateInfo</span><span class="p">.</span><span class="n">components</span><span class="p">;</span><span class="c1">//All VK_COMPONENT_SWIZZLE_IDENTITY</span>
<span class="n">imageViewCreateInfo</span><span class="p">.</span><span class="n">subresourceRange</span> <span class="o">=</span> <span class="p">{</span> <span class="n">VK_IMAGE_ASPECT_COLOR_BIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">swapchainImageCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">imageViewCreateInfo</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">swapchainImages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkCreateImageView</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imageViewCreateInfo</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">swapchainImageViews</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to create a swapchain image view!</span><span class="se">\n</span><span class="s">Error code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">,</span>
        <span class="n">abort</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><span class="type">VkImageViewCreateInfo</span> 除了pNext和flags以外的成员都在上述代码中。</div>
<div class="line">如我之前所说，image view定义了图像的使用方式，而 <code class="docutils literal notranslate"><span class="pre">viewType</span></code> 体现了这一点，可选的值如下：</div>
</div>
<blockquote>
<div><ul class="simple">
<li><p>VK_IMAGE_VIEW_TYPE_1D</p></li>
<li><p>VK_IMAGE_VIEW_TYPE_2D</p></li>
<li><p>VK_IMAGE_VIEW_TYPE_3D</p></li>
<li><p>VK_IMAGE_VIEW_TYPE_CUBE <span class="comment">//立方体贴图</span></p></li>
<li><p>VK_IMAGE_VIEW_TYPE_1D_ARRAY <span class="comment">//1D图像数组</span></p></li>
<li><p>VK_IMAGE_VIEW_TYPE_2D_ARRAY <span class="comment">//2D图像数组</span></p></li>
<li><p>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY <span class="comment">//立方体贴图数组</span></p></li>
</ul>
</div></blockquote>
<div class="line-block">
<div class="line">贴图数组是一系列大小完全一致的图像，构成数组后方便在shader中采样。</div>
<div class="line">立方体贴图以及贴图数组的具体内容将在今后讲解，对于交换链图像，我们的选择毫无疑问是VK_IMAGE_VIEW_TYPE_2D。</div>
<div class="line">（交换链中有好几张图像，但每张是单独使用的，不构成数组。）</div>
</div>
<div class="line-block">
<div class="line">我们可以通过 <code class="docutils literal notranslate"><span class="pre">components</span></code> 成员来重新映射RGBA通道，如果你不需要改变任何通道，那么使用默认的VK_COMPONENT_SWIZZLE_IDENTITY（即0）即可。</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">subresourceRange</span></code> 是一个 <span class="type">VkImageSubresourceRange</span> 结构体，我们今后还会经常看见它的，内容如下：</div>
<div class="line"><span class="kw">struct</span> <span class="type">VkImageSubresourceRange</span> {</div>
<div class="line-block">
<div class="line"><span class="type">VkImageAspectFlags</span> aspectMask; <span class="comment">//描述要使用图像的哪些方面←我不知道aspect是否有更合适的翻译</span></div>
<div class="line"><span class="type">uint32_t</span> baseMipLevel; <span class="comment">//如果生成了mipmap，填入起始mipmap级别</span></div>
<div class="line"><span class="type">uint32_t</span> levelCount; <span class="comment">//如果生成了mipmap，填入从起始mipmap级别往后，所要使用的mipmap级别数</span></div>
<div class="line"><span class="type">uint32_t</span> baseArrayLayer; <span class="comment">//如果是图像数组，在这里填入起始图层编号</span></div>
<div class="line"><span class="type">uint32_t</span> layerCount; <span class="comment">//如果是图像数组，填入从起始图层编号往后，所要使用的图层数</span></div>
</div>
<div class="line">};</div>
<div class="line">由于我们要使用图像的颜色通道，所以 <code class="docutils literal notranslate"><span class="pre">aspectMask</span></code> 是VK_IMAGE_ASPECT_COLOR_BIT。</div>
<div class="line">关于mipmap的概念会在讲到2D贴图时再做解说。你现在只需知道，屏幕缓冲是不需要额外的mipmap的，所以基本级别为0，所要使用的mipmap级别总数是1，代表只有一张最原始的图像。</div>
<div class="line">由于我们的单张交换链图像不是数组，所以起始图层编号是0，图层数为1。</div>
</div>
</div>
</div>
<div class="section" id="id5">
<h2>重建交换链<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">在 <span class="type">graphicsBase</span> 中加入以下函数（公有或私有请随意）：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*After initialization*/</span>
<span class="kt">void</span> <span class="nf">RecreateSwapchain</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">VkSurfaceCapabilitiesKHR</span> <span class="n">surfaceCapabilities</span><span class="p">{};</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span><span class="p">(</span><span class="n">physicalDevice</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">surfaceCapabilities</span><span class="p">))</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ graphicsBase ]</span><span class="se">\n</span><span class="s">Failed to get physical device surface capabilities!</span><span class="se">\n</span><span class="s">Error code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">,</span>
        <span class="n">abort</span><span class="p">();</span>
    <span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">imageExtent</span> <span class="o">=</span> <span class="n">surfaceCapabilities</span><span class="p">.</span><span class="n">currentExtent</span><span class="p">;</span>
    <span class="n">swapchainCreateInfo</span><span class="p">.</span><span class="n">oldSwapchain</span> <span class="o">=</span> <span class="n">swapchain</span><span class="p">;</span>
    <span class="n">vkDeviceWaitIdle</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
    <span class="n">CreateSwapchain_Internal</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">简要说明，重建交换链通常发生在窗口大小改变之后，所以你需要重新获取 <code class="docutils literal notranslate"><span class="pre">surfaceCapabilities</span></code> ，以取得窗口大小。</div>
<div class="line">然后重建交换链时填入旧的交换链，这样能加快重建的速度，而旧的交换链及其图像也会被自动销毁。</div>
<div class="line">以及别忘了等待GPU空闲，确保旧的交换链没有在被使用。</div>
</div>
</div>
<div class="section" id="id6">
<h2>设置相关回调及销毁对象<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">由于有一堆跟窗口图像大小相关的Vulkan对象，我们必须设置回调函数，以在重建交换链时，一并重建这些对象。</div>
<div class="line">在 <span class="type">graphicsBase</span> 中加入以下内容：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)()</span><span class="o">&gt;</span> <span class="n">callbacks_createSwapchain</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)()</span><span class="o">&gt;</span> <span class="n">callbacks_destroySwapchain</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">PushCallback_CreateSwapchain</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)())</span> <span class="p">{</span>
        <span class="n">callbacks_createSwapchain</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">function</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">PushCallback_DestroySwapchain</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)())</span> <span class="p">{</span>
        <span class="n">callbacks_destroySwapchain</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">function</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>然后在正确的时候调用它们：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">CreateSwapchain</span><span class="p">(</span><span class="kt">bool</span> <span class="n">limit_framerate</span> <span class="o">=</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="c1">//放在本函数的最后</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">callbacks_createSwapchain</span><span class="p">)</span>
        <span class="n">i</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">RecreateSwapchain</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="c1">//放在本函数的最后</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">callbacks_destroySwapchain</span><span class="p">)</span>
        <span class="n">i</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">callbacks_createSwapchain</span><span class="p">)</span>
        <span class="n">i</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">注意在销毁逻辑设备前销毁交换链，并调用 <code class="docutils literal notranslate"><span class="pre">callbacks_destroySwapchain</span></code> 中的函数</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">~</span><span class="n">graphicsBase</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vkDeviceWaitIdle</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="cp">#ifndef NDEBUG</span>
    <span class="n">DestroyDebugMessenger</span><span class="p">();</span>
<span class="cp">#endif</span>
    <span class="n">vkDestroySwapchainKHR</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">swapchain</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">swapchainImageViews</span><span class="p">)</span>
        <span class="n">vkDestroyImageView</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">callbacks_destroySwapchain</span><span class="p">)</span>
        <span class="n">i</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">callbacks_cleanUp</span><span class="p">)</span>
        <span class="n">i</span><span class="p">();</span>
    <span class="n">vkDestroyDevice</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
    <span class="n">vkDestroySurfaceKHR</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
    <span class="n">vkDestroyInstance</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">另外，修改 <code class="docutils literal notranslate"><span class="pre">CreateSwapchain_Internal</span></code> ，在创建取得交换链图像之后，创建image view之前，加入以下代码：</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">CreateSwapchain_Internal</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">//...</span>
<span class="c1">//前面是取得交换链图像的代码</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">swapchainImageViews</span><span class="p">)</span>
        <span class="n">vkDestroyImageView</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span><span class="c1">//nullptr是pAllocator</span>
<span class="c1">//后面是创建image view的代码</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">因为这个函数是 <code class="docutils literal notranslate"><span class="pre">CreateSwapchain</span></code> 和 <code class="docutils literal notranslate"><span class="pre">RecreateSwapchain</span></code> 共用的，而重建交换链不会自动销毁原有的image view，所以我们得手动加入相关代码。</div>
</div>
</div>
<div class="section" id="id7">
<h2>试运行<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">在 <code class="docutils literal notranslate"><span class="pre">InitializeWindow</span></code> 中， <code class="docutils literal notranslate"><span class="pre">vulkan::graphicsBase::Base().CreateLogicalDevice()</span></code> 后添加  <code class="docutils literal notranslate"><span class="pre">vulkan::graphicsBase::Base().CreateSwapchain(limit_framerate)</span></code>，然后运行程序。</div>
<div class="line">眼下你应该仍旧看不到任何内容，只有一个白屏，让交换链工作还需一些同步措施。</div>
<div class="line">你要做的是在Debug模式下检查程序是否能正常运行，以及开关程序时验证层是否有报错。</div>
<div class="line">如果出现了任何问题，请到Github上比照我的代码。</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Ch1-4%20%E6%89%BF%E5%89%8D%E5%90%AF%E5%90%8E.html" class="btn btn-neutral float-right" title="Ch1-4 承前启后" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Ch1-2%20%E5%88%9B%E5%BB%BAVk%E5%AE%9E%E4%BE%8B%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87.html" class="btn btn-neutral float-left" title="Ch1-2 创建Vk实例与逻辑设备" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Qiao Wu.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>