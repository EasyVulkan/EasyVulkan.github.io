<!DOCTYPE html>
<html class="writer-html5" lang="zh" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ch8-3 延迟渲染 &mdash; EasyVulkan</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="Ap1-1 运行期编译GLSL" href="Ap1-1%20%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%BC%96%E8%AF%91GLSL.html" />
    <link rel="prev" title="Ch8-2 深度测试和深度可视化" href="Ch8-2%20%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%8F%AF%E8%A7%86%E5%8C%96.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> EasyVulkan
            <img src="_static/logo1.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">第一章 初始化</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch1-0%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html">Ch1-0 准备工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-1%20%E5%88%9B%E5%BB%BAGLFW%E7%AA%97%E5%8F%A3.html">Ch1-1 创建GLFW窗口</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B.html">Ch1-2 初始化流程</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-3%20%E5%88%9B%E5%BB%BAVK%E5%AE%9E%E4%BE%8B%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87.html">Ch1-3 创建VK实例与逻辑设备</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch1-4%20%E5%88%9B%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE.html">Ch1-4 创建交换链</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第二章 绘制一个三角形</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch2-0%20%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86%E5%8F%8A%E4%B8%80%E4%BA%9B%E8%BE%85%E5%8A%A9%E7%B1%BB.html">Ch2-0 代码整理及一些辅助类</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch2-1%20Rendering%20Loop.html">Ch2-1 Rendering Loop</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch2-2%20%E5%88%9B%E5%BB%BA%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93%E5%92%8C%E5%B8%A7%E7%BC%93%E5%86%B2.html">Ch2-2 创建渲染通道和帧缓冲</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch2-3%20%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%BA%BF%E5%B9%B6%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2.html">Ch2-3 创建管线并绘制三角形</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第三章 纵观Vulkan</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch3-1%20%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD.html">Ch3-1 同步原语</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-2%20%E5%9B%BE%E5%83%8F%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch3-2 图像与缓冲区</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-3%20%E7%AE%A1%E7%BA%BF%E5%B8%83%E5%B1%80%E5%92%8C%E7%AE%A1%E7%BA%BF.html">Ch3-3 管线布局和管线</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-4%20%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93%E5%92%8C%E5%B8%A7%E7%BC%93%E5%86%B2.html">Ch3-4 渲染通道和帧缓冲</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-5%20%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch3-5 命令缓冲区</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-6%20%E6%8F%8F%E8%BF%B0%E7%AC%A6.html">Ch3-6 描述符</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch3-7%20%E9%87%87%E6%A0%B7%E5%99%A8.html">Ch3-7 采样器</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第四章 着色器</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch4-1%20%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E7%BB%84.html">Ch4-1 着色器模组</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch4-2%20%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8.html">Ch4-2 顶点着色器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch4-3%20%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8.html">Ch4-3 片段着色器</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第五章 封装常用对象</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch5-0%20VKBase%2B.h.html">Ch5-0 VKBase+.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch5-1%20%E5%90%84%E7%A7%8D%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch5-1 各种缓冲区</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch5-2%202D%E8%B4%B4%E5%9B%BE%E5%8F%8A%E7%94%9F%E6%88%90Mipmap.html">Ch5-2 2D贴图及生成Mipmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch5-3%202D%E8%B4%B4%E5%9B%BE%E6%95%B0%E7%BB%84.html">Ch5-3 2D贴图数组</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第六章 进阶Vulkan</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch6-0%20%E4%BD%BF%E7%94%A8%E6%96%B0%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7.html">Ch6-0 使用新版本特性</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch6-1%20%E6%97%A0%E5%9B%BE%E5%83%8F%E5%B8%A7%E7%BC%93%E5%86%B2.html">Ch6-1 无图像帧缓冲</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch6-2%20%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93.html">Ch6-2 动态渲染</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第七章 基础示例</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ch7-1%20%E5%88%9D%E8%AF%86%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch7-1 初识顶点缓冲区</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch7-2%20%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch7-2 初识索引缓冲区</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch7-3%20%E5%88%9D%E8%AF%86%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%BB%98%E5%88%B6.html">Ch7-3 初识实例化绘制</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch7-4%20%E5%88%9D%E8%AF%86Push%20Constant.html">Ch7-4 初识Push Constant</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch7-5%20%E5%88%9D%E8%AF%86Uniform%E7%BC%93%E5%86%B2%E5%8C%BA.html">Ch7-5 初识Uniform缓冲区</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch7-6%20%E6%8B%B7%E8%B4%9D%E5%9B%BE%E5%83%8F%E5%88%B0%E5%B1%8F%E5%B9%95.html">Ch7-6 拷贝图像到屏幕</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch7-7%20%E4%BD%BF%E7%94%A8%E8%B4%B4%E5%9B%BE.html">Ch7-7 使用贴图</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">第八章 简单示例</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Ch8-1%20%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93.html">Ch8-1 离屏渲染</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ch8-2%20%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%8F%AF%E8%A7%86%E5%8C%96.html">Ch8-2 深度测试和深度可视化</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Ch8-3 延迟渲染</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">冯氏光照</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">创建渲染通道和帧缓冲</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">顶点和索引数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="#uniform">Uniform数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">书写着色器并创建管线</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gbuffer-vert-shader">GBuffer.vert.shader</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gbuffer-frag-shader">GBuffer.frag.shader</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition-vert-shader">Composition.vert.shader</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition-frag-shader">Composition.frag.shader</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">写入描述符</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">绘制</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">附录</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Ap1-1%20%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%BC%96%E8%AF%91GLSL.html">Ap1-1 运行期编译GLSL</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EasyVulkan</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Ch8-3 延迟渲染</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ch8-3">
<h1>Ch8-3 延迟渲染（未完成）<a class="headerlink" href="#ch8-3" title="Permalink to this heading"></a></h1>
<p>
    本节的<span class="path">main.cpp</span>对应示例代码中的：<a href="https://github.com/EasyVulkan/EasyVulkan.github.io/tree/main/solution/EasyVulkan_Ch8/Ch8-3.hpp">Ch8-3.hpp</a>
</p>
<p>
    虽然延迟渲染属于图形编程常识性内容，但这里姑且还是简单介绍下概念。
</p>
<p>
    <strong>正向渲染</strong>
    <br>
    在绘制场景中每个物件的时候完成其光照计算，这种传统的渲染方式即是正向渲染（forward rendering）。
</p>
<p>
    <strong>延迟渲染</strong>
    <br>
    渲染过程中绘制的许多片段最终会因深度测试而被遮挡掉，那么显然，打从一开始就没必要对这些片段进行光照计算。
    <br>
    延迟渲染（deferred rendering）即是将本该在绘制每个物件时进行的光照计算延后，只对最终保留下来的片段进行光照计算，以此来大幅节省运算开销的渲染手段。
</p>
<p>
    延迟渲染的具体做法分为两步：
    <br>
    1.绘制场景中的物件但不计算光照，而是将光照计算所需的信息写入图像附件，这些图像附件统称为几何缓冲（G-buffer）
    <br>
    2.对交换链图像中的每个像素，读取G-buffer中相应位置的数据，进行光照计算，这一步叫合成（composition）
    <br>
    如此一来，进行光照计算的片段着色器调用次数，便等于交换链图像的像素数，在确定的分辨率下是个恒定值，不会因场景中物件的增多而增长。
</p>
<p>
    <strong>前向透明度</strong>
    <br>
    渲染半透明物体时，需要透出底下的颜色。
    <br>
    因为延迟渲染中的G-buffer只有深度测试后最终留下来的片段，从中无法获取所谓“底下”的信息，因此无法延迟渲染半透明物体。
    <br>
    前向透明度（forward transparency）指在延迟渲染结束时保留深度值，然后正向渲染半透明物体的做法。
</p>
<p>
    本文以演示Vulkan API为主要目的，实现一套最简单的延迟渲染的流程，不考虑前向透明度。
</p><section id="id1">
<h2>冯氏光照<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h2>
<p>
    考虑到讲解BRDF光照模型估计得花上四节的篇幅，这一节就用较为老旧的冯氏光照（Phong lighting）模型吧。
</p>
<p>
    冯氏光照模型使用较为简单的材质参数，颜色和高光度，计算物体表面的漫反射和高光。
</p>
<p>
    TODO 施工中。
</p></section>
<section id="id2">
<h2>创建渲染通道和帧缓冲<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h2>
<p>
    对于通过延迟渲染实现冯氏光照，渲染通道的结构一般是这样的：
    <br>
    （下图中子通道#0的G-buffer例图为带有透明度的原图，子通道#1的例图将RGBA中A的数值以灰度图的形式可视化）
</p>
<img alt="_images/ch8-3-1.png" src="_images/ch8-3-1.png">
<ul>
    <li>
        <p>
            Vulkan标准规定实现必须支持<span class="enum">VK_FORMAT_R16G16B16A16_SFLOAT</span>格式的颜色附件，但是否支持<span class="enum">VK_FORMAT_R16G16B16_SFLOAT</span>格式的颜色附件则取决于硬件。因此虽然位置坐标和法向量都只有三个分量，出于省事和可移植性考虑，这里使用四分量的格式。
        </p>
    </li>
    <li>
        <p>
            如果你觉得16位浮点数的精度不够，Vulkan标准也规定了实现必须支持<span class="enum">VK_FORMAT_R32G32B32A32_SFLOAT</span>格式的颜色附件（不保证能混色，不过G-buffer用不着混色）。但16位浮点附件和32位浮点附件最终算出的颜色只有约（8位色模式下）4个色阶的差异。
        </p>
    </li>
</ul>
<p>
    世界空间的位置坐标，可以通过深度附件中的深度值、片段的NDC坐标、投影矩阵、观察矩阵算得，因此上图中还可以减少一个图像附件以节省设备内存。
    <br>
    深度值是用来计算相机坐标系下的z坐标的，这一步可以被省掉：用来存法向量的图像附件只用了三个分量，可以将相机空间中的z坐标存入其第四个分量。
    <br>
    于是结构变成这样：
</p>
<img alt="_images/ch8-3-2.png" src="_images/ch8-3-2.png">
<p>
    在<span class="path">EasyVulkan.hpp</span>，easyVulkan命名空间中，定义相关的图像附件，及用来创建这些附件、渲染通道、帧缓冲的函数<span class="fn">CreateRpwf_DeferredToScreen</span>(...)。
    <br>
    为简化代码，这次就不为每张交换链图像分别创建一套对应的图像附件了：
</p>
<pre class="code">
<span class="type">colorAttachment</span> ca_deferredToScreen_normalZ;        <span class="cmt">//法线和相机坐标系下的z值</span>
<span class="type">colorAttachment</span> ca_deferredToScreen_albedoSpecular; <span class="cmt">//颜色和高光度</span>
<span class="type">depthStencilAttachment</span> dsa_deferredToScreen;        <span class="cmt">//深度</span>
<span class="kw">const auto</span>&amp; <span class="fn">CreateRpwf_DeferredToScreen</span>(<span class="type">VkFormat</span> <span class="par">depthStencilFormat</span> = <span class="enum">VK_FORMAT_D24_UNORM_S8_UINT</span>) {
    <span class="kw">static</span> <span class="type">renderPassWithFramebuffers</span> rpwf;
    <span class="mcr">ExecuteOnce</span>(rpwf); <span class="cmt">//防止重复执行</span>
    <span class="kw">static</span> <span class="type">VkFormat</span> _depthStencilFormat = <span class="par">depthStencilFormat</span>; <span class="cmt">//因为一会儿需要用lambda定义重建交换链时的回调函数，把格式存到静态变量</span>

    <span class="cmt">/*待后续填充*/</span>

    <span class="kw">return</span> rpwf;
}
</pre>
<p>
    四个图像附件的描述如下：
</p>
<pre class="code">
<span class="type">VkAttachmentDescription</span> attachmentDescriptions[4] = {
    { <span class="cmt">//交换链图像</span>
        .format = <span class="type">graphicsBase</span>::<span class="sfn">Base</span>().<span class="fn">SwapchainCreateInfo</span>().imageFormat,
        .samples = <span class="enum">VK_SAMPLE_COUNT_1_BIT</span>,
        .loadOp = <span class="enum">VK_ATTACHMENT_LOAD_OP_CLEAR</span>,
        .storeOp = <span class="enum">VK_ATTACHMENT_STORE_OP_STORE</span>,
        .stencilLoadOp = <span class="enum">VK_ATTACHMENT_LOAD_OP_DONT_CARE</span>,
        .stencilStoreOp = <span class="enum">VK_ATTACHMENT_STORE_OP_DONT_CARE</span>,
        .finalLayout = <span class="enum">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</span> },
    { <span class="cmt">//法线和相机坐标系下的z值</span>
        .format = <span class="enum">VK_FORMAT_R16G16B16A16_SFLOAT</span>,
        .samples = <span class="enum">VK_SAMPLE_COUNT_1_BIT</span>,
        .loadOp = <span class="enum">VK_ATTACHMENT_LOAD_OP_CLEAR</span>,
        .storeOp = <span class="enum">VK_ATTACHMENT_STORE_OP_DONT_CARE</span>,
        .stencilLoadOp = <span class="enum">VK_ATTACHMENT_LOAD_OP_DONT_CARE</span>,
        .stencilStoreOp = <span class="enum">VK_ATTACHMENT_STORE_OP_DONT_CARE</span>,
        .finalLayout = <span class="enum">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</span> },
    { <span class="cmt">//颜色和高光度</span>
        .format = <span class="enum">VK_FORMAT_R8G8B8A8_UNORM</span>, <span class="cmt">//与上一个只有格式不同</span>
        .samples = <span class="enum">VK_SAMPLE_COUNT_1_BIT</span>,
        .loadOp = <span class="enum">VK_ATTACHMENT_LOAD_OP_CLEAR</span>,
        .storeOp = <span class="enum">VK_ATTACHMENT_STORE_OP_DONT_CARE</span>,
        .stencilLoadOp = <span class="enum">VK_ATTACHMENT_LOAD_OP_DONT_CARE</span>,
        .stencilStoreOp = <span class="enum">VK_ATTACHMENT_STORE_OP_DONT_CARE</span>,
        .finalLayout = <span class="enum">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</span> },
    { <span class="cmt">//深度和模板</span>
        .format = _depthStencilFormat,
        .samples = <span class="enum">VK_SAMPLE_COUNT_1_BIT</span>,
        .loadOp = <span class="enum">VK_ATTACHMENT_LOAD_OP_CLEAR</span>,
        .storeOp = <span class="enum">VK_ATTACHMENT_STORE_OP_DONT_CARE</span>,
        .stencilLoadOp = _depthStencilFormat &gt;= <span class="enum">VK_FORMAT_S8_UINT</span> ? <span class="enum">VK_ATTACHMENT_LOAD_OP_CLEAR</span> : <span class="enum">VK_ATTACHMENT_LOAD_OP_DONT_CARE</span>,
        .stencilStoreOp = <span class="enum">VK_ATTACHMENT_STORE_OP_DONT_CARE</span>,
        .finalLayout = <span class="enum">VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</span> }
};
</pre>
<p>
    子通道的描述：
</p>
<pre class="code">
<span class="type">VkAttachmentReference</span> attachmentReferences_subpass0[3] = {
    { 1, <span class="enum">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span> },        <span class="cmt">//对应normalZ</span>
    { 2, <span class="enum">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span> },        <span class="cmt">//对应albedoSpecular</span>
    { 3, <span class="enum">VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</span> } <span class="cmt">//对应深度和模板</span>
};
<span class="type">VkAttachmentReference</span> attachmentReferences_subpass1[3] = {
    { 1, <span class="enum">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</span> }, <span class="cmt">//对应normalZ</span>
    { 2, <span class="enum">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</span> }, <span class="cmt">//对应albedoSpecular</span>
    { 0, <span class="enum">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span> }  <span class="cmt">//对应交换链图像</span>
};
<span class="type">VkSubpassDescription</span> subpassDescriptions[2] = {
    { <span class="cmt">//第一个子通道，生成G-buffer</span>
        .pipelineBindPoint = <span class="enum">VK_PIPELINE_BIND_POINT_GRAPHICS</span>,
        .colorAttachmentCount = 2,
        .pColorAttachments = attachmentReferences_subpass0,
        .pDepthStencilAttachment = attachmentReferences_subpass0 + 2 },
    { <span class="cmt">//第二个子通道，进行composition</span>
        .pipelineBindPoint = <span class="enum">VK_PIPELINE_BIND_POINT_GRAPHICS</span>,
        .inputAttachmentCount = 2,
        .pInputAttachments = attachmentReferences_subpass1, <span class="cmt">//将两张G-buffer用作输入附件</span>
        .colorAttachmentCount = 1,
        .pColorAttachments = attachmentReferences_subpass1 + 2 }
};
</pre>
<p>
    渲染通道开始时的子通道依赖：
</p>
<pre class="code">
<span class="type">VkSubpassDependency</span> subpassDependencies[2] = {
    {
        .srcSubpass = <span class="mcr">VK_SUBPASS_EXTERNAL</span>,
        .dstSubpass = 0,
        .srcStageMask = <span class="enum">VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</span>,
        .dstStageMask = <span class="enum">VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</span>,
        .srcAccessMask = 0,
        .dstAccessMask = <span class="enum">VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</span>,
        .dependencyFlags = <span class="enum">VK_DEPENDENCY_BY_REGION_BIT</span> },
    { <span class="cmt">/*渲染通道结束时的依赖，待填充*/</span> }
};
</pre>
<ul>
    <li>
        <p>
            srcStageMask是<span class="enum">VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</span>（惯例说明：因有栅栏同步，填0也无妨），指代前一帧中在片段着色器中读写G-buffer，除此之外与先前<a class="reference internal" href="Ch8-2%20%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%8F%AF%E8%A7%86%E5%8C%96.html#id4">Ch8-2 深度测试和深度可视化</a>中渲染通道开始时的依赖相同。
        </p>
    </li>
</ul>
<p>
    填写子通道#0和子通道#1之间的依赖，创建渲染通道：
</p>
<pre class="code">
<span class="type">VkSubpassDependency</span> subpassDependencies[2] = {
    {
        .srcSubpass = <span class="mcr">VK_SUBPASS_EXTERNAL</span>,
        .dstSubpass = 0,
        .srcStageMask = <span class="enum">VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</span>,
        .dstStageMask = <span class="enum">VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</span>,
        .srcAccessMask = 0,
        .dstAccessMask = <span class="enum">VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</span>,
        .dependencyFlags = <span class="enum">VK_DEPENDENCY_BY_REGION_BIT</span> },
    {
        .srcSubpass = 0,
        .dstSubpass = 1,
        .srcStageMask = <span class="enum">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</span>,
        .dstStageMask = <span class="enum">VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</span>,
        .srcAccessMask = <span class="enum">VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</span>,
        .dstAccessMask = <span class="enum">VK_ACCESS_INPUT_ATTACHMENT_READ_BIT</span>,
        .dependencyFlags = <span class="enum">VK_DEPENDENCY_BY_REGION_BIT</span> }
};
<span class="type">VkRenderPassCreateInfo</span> renderPassCreateInfo = {
    .attachmentCount = 4,
    .pAttachments = attachmentDescriptions,
    .subpassCount = 2,
    .pSubpasses = subpassDescriptions,
    .dependencyCount = 2,
    .pDependencies = subpassDependencies
};
rpwf.renderPass.<span class="fn">Create</span>(renderPassCreateInfo);
</pre>
<ul>
    <li>
        <p>
            这里即是要求子通道#0中将颜色输出到G-buffer后，在子通道#1中片段着色器读取这些输入附件（<span class="enum">VK_ACCESS_INPUT_ATTACHMENT_READ_BIT</span>）前完成包括交换链图像在内的内存布局转换。
        </p>
    </li>
</ul>
<p>
    创建相应的图像附件和帧缓冲。
    <br>
    因为用作输入附件的G-buffer在渲染通道结束后就用不着了，图像用途中指定<span class="enum">VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</span>：
</p>
<pre class="code">
<span class="type">colorAttachment</span> ca_deferredToScreen_normalZ;        <span class="cmt">//法线和相机坐标系下的z值</span>
<span class="type">colorAttachment</span> ca_deferredToScreen_albedoSpecular; <span class="cmt">//颜色和高光度</span>
<span class="type">depthStencilAttachment</span> dsa_deferredToScreen;        <span class="cmt">//深度</span>
<span class="kw">const auto</span>&amp; <span class="fn">CreateRpwf_DeferredToScreen</span>(<span class="type">VkFormat</span> <span class="par">depthStencilFormat</span> = <span class="enum">VK_FORMAT_D24_UNORM_S8_UINT</span>) {
    <span class="cmt">/*...前面略*/</span>
    <span class="kw">auto</span> CreateFramebuffers = [] {
        rpwf.framebuffers.<span class="fn">resize</span>(<span class="type">graphicsBase</span>::<span class="sfn">Base</span>().<span class="fn">SwapchainImageCount</span>());
        ca_deferredToScreen_normalZ.<span class="fn">Create</span>(<span class="enum">VK_FORMAT_R16G16B16A16_SFLOAT</span>, windowSize, 1, <span class="enum">VK_SAMPLE_COUNT_1_BIT</span>, <span class="enum">VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</span> | <span class="enum">VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</span>);
        ca_deferredToScreen_albedoSpecular.<span class="fn">Create</span>(<span class="enum">VK_FORMAT_R8G8B8A8_UNORM</span>, windowSize, 1, <span class="enum">VK_SAMPLE_COUNT_1_BIT</span>, <span class="enum">VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</span> | <span class="enum">VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</span>);
        dsa_deferredToScreen.<span class="fn">Create</span>(_depthStencilFormat, windowSize, 1, <span class="enum">VK_SAMPLE_COUNT_1_BIT</span>, <span class="enum">VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</span>);
        <span class="type">VkImageView</span> attachments[4] = {
            <span class="mcr">VK_NULL_HANDLE</span>,
            ca_deferredToScreen_normalZ.<span class="fn">ImageView</span>(),
            ca_deferredToScreen_albedoSpecular.<span class="fn">ImageView</span>(),
            dsa_deferredToScreen.<span class="fn">ImageView</span>()
        };
        <span class="type">VkFramebufferCreateInfo</span> framebufferCreateInfo = {
            .renderPass = rpwf.renderPass,
            .attachmentCount = 4,
            .pAttachments = attachments,
            .width = windowSize.width,
            .height = windowSize.height,
            .layers = 1
        };
        <span class="kw">for</span> (<span class="type">size_t</span> i = 0; i &lt; <span class="type">graphicsBase</span>::<span class="sfn">Base</span>().<span class="fn">SwapchainImageCount</span>(); i++)
            attachments[0] = <span class="type">graphicsBase</span>::<span class="sfn">Base</span>().<span class="fn">SwapchainImageView</span>(i),
            rpwf.framebuffers[i].<span class="fn">Create</span>(framebufferCreateInfo);
    };
    <span class="kw">auto</span> DestroyFramebuffers = [] {
        ca_deferredToScreen_normalZ.<span class="fn">~colorAttachment</span>();
        ca_deferredToScreen_albedoSpecular.<span class="fn">~colorAttachment</span>();
        dsa_deferredToScreen.<span class="fn">~depthStencilAttachment</span>();
        rpwf.framebuffers.<span class="fn">clear</span>();
    };
    <span class="type">graphicsBase</span>::<span class="sfn">Base</span>().<span class="fn">AddCallback_CreateSwapchain</span>(CreateFramebuffers);
    <span class="type">graphicsBase</span>::<span class="sfn">Base</span>().<span class="fn">AddCallback_DestroySwapchain</span>(DestroyFramebuffers);
    CreateFramebuffers();
    <span class="kw">return</span> rpwf;
}
</pre></section>
<section id="id3">
<h2>顶点和索引数据<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h2>
<p>
    在<span class="path">main.cpp</span>中定义顶点数据的结构体：
</p>
<pre class="code">
<span class="kw">struct</span> <span class="type">vertex</span> {
    glm::<span class="type">vec3</span> position;
    glm::<span class="type">vec3</span> normal;
    glm::<span class="type">vec4</span> albedoSpecular;
};
</pre>
<p>
    基于前一节的顶点数据做修改。
    <br>
    因为是立方体，很容易就能写出法线。颜色和高光度随意，我这里用白色以反射任何颜色的光，高光度用了1，你可以指定超过1：
</p>
<pre class="code">
<span class="type">vertex</span> vertices[] = {
    <span class="cmt">//x+</span>
    { {  1,  1, -1 }, {  1,  0,  0 }, { 1, 1, 1, 1 } },
    { {  1, -1, -1 }, {  1,  0,  0 }, { 1, 1, 1, 1 } },
    { {  1,  1,  1 }, {  1,  0,  0 }, { 1, 1, 1, 1 } },
    { {  1, -1,  1 }, {  1,  0,  0 }, { 1, 1, 1, 1 } },
    <span class="cmt">//x-</span>
    { { -1,  1,  1 }, { -1,  0,  0 }, { 1, 1, 1, 1 } },
    { { -1, -1,  1 }, { -1,  0,  0 }, { 1, 1, 1, 1 } },
    { { -1,  1, -1 }, { -1,  0,  0 }, { 1, 1, 1, 1 } },
    { { -1, -1, -1 }, { -1,  0,  0 }, { 1, 1, 1, 1 } },
    <span class="cmt">//y+</span>
    { {  1,  1, -1 }, {  0,  1,  0 }, { 1, 1, 1, 1 } },
    { {  1,  1,  1 }, {  0,  1,  0 }, { 1, 1, 1, 1 } },
    { { -1,  1, -1 }, {  0,  1,  0 }, { 1, 1, 1, 1 } },
    { { -1,  1,  1 }, {  0,  1,  0 }, { 1, 1, 1, 1 } },
    <span class="cmt">//y-</span>
    { {  1, -1, -1 }, {  0, -1,  0 }, { 1, 1, 1, 1 } },
    { { -1, -1, -1 }, {  0, -1,  0 }, { 1, 1, 1, 1 } },
    { {  1, -1,  1 }, {  0, -1,  0 }, { 1, 1, 1, 1 } },
    { { -1, -1,  1 }, {  0, -1,  0 }, { 1, 1, 1, 1 } },
    <span class="cmt">//z+</span>
    { {  1,  1,  1 }, {  0,  0,  1 }, { 1, 1, 1, 1 } },
    { {  1, -1,  1 }, {  0,  0,  1 }, { 1, 1, 1, 1 } },
    { { -1,  1,  1 }, {  0,  0,  1 }, { 1, 1, 1, 1 } },
    { { -1, -1,  1 }, {  0,  0,  1 }, { 1, 1, 1, 1 } },
    <span class="cmt">//z-</span>
    { { -1,  1, -1 }, {  0,  0, -1 }, { 1, 1, 1, 1 } },
    { { -1, -1, -1 }, {  0,  0, -1 }, { 1, 1, 1, 1 } },
    { {  1,  1, -1 }, {  0,  0, -1 }, { 1, 1, 1, 1 } },
    { {  1, -1, -1 }, {  0,  0, -1 }, { 1, 1, 1, 1 } }
};
<span class="type">vertexBuffer</span> vertexBuffer_perVertex(<span class="kw">sizeof</span> vertices);
vertexBuffer_perVertex.<span class="type">TransferData</span>(vertices);
</pre>
<p>
    逐实例输入的位移、索引数据就跟<a class="reference internal" href="Ch8-2%20%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%8F%AF%E8%A7%86%E5%8C%96.html#id5">Ch8-2</a>中一样吧。
</p></section>
<section id="uniform">
<h2>Uniform数据<a class="headerlink" href="#uniform" title="Permalink to this heading"></a></h2>
<p>
    这次来尝试使用观察矩阵。
    <br>
    因为push constant的128字节不够，我打算把投影矩阵、观察矩阵、点光源信息都放进单个uniform缓冲区：
</p>
<pre class="code">
<span class="kw">struct</span> {
    glm::<span class="type">mat4</span> proj = <span class="fn">FlipVertical</span>(glm::<span class="fn">infinitePerspectiveLH_ZO</span>(glm::<span class="fn">radians</span>(60.f), <span class="kw">float</span>(windowSize.width) / windowSize.height, 0.1f));
    glm::<span class="type">mat4</span> view = <span class="cmt">/*待填充*/</span>;
    <span class="type">int32_t</span> lightCount;
    <span class="kw">struct</span> {
        <span class="kw">alignas</span>(16) glm::<span class="type">vec3</span> position; <span class="cmt">//光源位置</span>
        <span class="kw">alignas</span>(16) glm::<span class="type">vec3</span> color;    <span class="cmt">//光的颜色</span>
        <span class="kw">float</span> strength;                 <span class="cmt">//光的强度</span>
    } lights[8];
} descriptorConstants;
</pre>
<p>
    GLM中提供了用于生成观察矩阵的函数glm::<span class=fn>lookAt</span>(...)：
</p>
<pre class="code">
<span class="type">mat4</span> <span class=fn>lookAt</span>(
    <span class="type">vec3</span> <span class="par">eye</span>,    <span class="cmt">//观察者所在位置</span>
    <span class="type">vec3</span> <span class="par">center</span>, <span class="cmt">//观察者所视方向上的点</span>
    <span class="type">vec3</span> <span class="par">up</span>      <span class="cmt">//头顶的方向（请不要纠结观察者是不是人有没有头之类的问题）</span>
);
</pre>
<ul>
    <li>
        <p>
            <span class="par">up</span>不必与观察者所视方向垂直，但不得与观察者所视方向完全同向/反向。
        </p>
    </li>
</ul>
<p>
    <code><span class="par">center</span> - <span class="par">eye</span></code>即是观察者所视方向，称为前向量。
    <br>
    <span class="par">up</span>与前向量叉乘可得到指向观察者右方的向量，称为右向量。
    <br>
    前向量与右向量叉乘得到的结果叫上向量。
    <br>
    右向量、上向量、前向量，世界坐标系中的这三个向量与相机空间中三条坐标轴的正方向一一对应。
</p>
<p>
    下面代码中，我显式地调用了glm::<span class=fn>lookAt</span>(...)的左手系版本glm::<span class=fn>lookAtLH</span>(...)。
    <br>
    生成的观察矩阵从世界坐标原点看向+z方向，前向量为<code>{ 0, 0, 1 }</code>，则<span class="par">up</span>为<code>{ -1, 0, 0 }</code>相当于将头逆时针倾斜90°：
</p>
<pre class="code">
glm::<span class="type">mat4</span> view = glm::<span class="fn">lookAtLH</span>(glm::<span class="type">vec3</span>(0, 0, 0), glm::<span class="type">vec3</span>(0, 0, 1), glm::<span class="type">vec3</span>(-1, 0, 0));
</pre>
<p>
    来指定点光源，虽然我前面让<span class="var">lights</span>有8个元素，这里就省事点只用分别为红绿蓝的三个光源，届时哪个光打在哪儿也能分得很清楚。
    <br>
    最后把数据扔进uniform缓冲区。
</p>
<pre class="code">
descriptorConstants.lightCount = 3;
descriptorConstants.lights[0] = { { 0.f,  4.f,  0.f }, { 1.f, 0.f, 0.f }, 100.f }; <span class="cmt">//红光</span>
descriptorConstants.lights[1] = { { 0.f,  0.f, 16.f }, { 0.f, 1.f, 0.f }, 100.f }; <span class="cmt">//绿光</span>
descriptorConstants.lights[2] = { { 0.f, -4.f,  0.f }, { 0.f, 0.f, 1.f }, 100.f }; <span class="cmt">//蓝光</span>
<span class="type">uniformBuffer</span> uniformBuffer(<span class="kw">sizeof</span> descriptorConstants);
uniformBuffer.<span class="fn">TransferData</span>(descriptorConstants);
</pre>
<p>
    在这里预先展示下届时的效果：
</p>
<img alt="_images/ch8-3-3.png" src="_images/ch8-3-3.png"></section>
<ul>
    <li>
        <p>
            因“将头逆时针倾斜90°”，与前一节中的图像相比，视野中的物体顺时针转了90°。
        </p>
    </li>
</ul>
<section id="id4">
<h2>书写着色器并创建管线<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h2>
<section id="gbuffer-vert-shader">
<h3>GBuffer.vert.shader<a class="headerlink" href="#gbuffer-vert-shader" title="Permalink to this heading"></a></h3>
<pre class="code">
<span class="pragma">#version</span> 460
<span class="pragma">#pragma shader_stage</span>(vertex)

<span class="kw">layout</span>(location = 0) <span class="kw">in</span> <span class="type">vec3</span> i_Position;         <span class="cmt">//逐顶点</span>
<span class="kw">layout</span>(location = 1) <span class="kw">in</span> <span class="type">vec3</span> i_Normal;           <span class="cmt">//逐顶点</span>
<span class="kw">layout</span>(location = 2) <span class="kw">in</span> <span class="type">vec4</span> i_AlbedoSpecular;   <span class="cmt">//逐顶点</span>
<span class="kw">layout</span>(location = 3) <span class="kw">in</span> <span class="type">vec3</span> i_InstancePosition; <span class="cmt">//逐实例</span>
<span class="kw">layout</span>(location = 0) <span class="kw">out</span> <span class="type">vec4</span> o_NormalZ;
<span class="kw">layout</span>(location = 1) <span class="kw">out</span> <span class="type">vec4</span> o_AlbedoSpecular;
<span class="kw">layout</span>(binding = 0) <span class="kw">uniform</span> descriptorConstants_pv {
    <span class="type">mat4</span> proj;
    <span class="type">mat4</span> view; <span class="cmt">//观察矩阵</span>
};

<span class="kw">void</span> <span class="fn">main</span>() {
    <span class="type">vec3</span> position = i_Position + i_InstancePosition;
    gl_Position = proj * view * <span class="type">vec4</span>(position, 1);
    o_NormalZ = <span class="type">vec4</span>(i_Normal, gl_Position.w); <span class="cmt">//此处gl_Position.w等于相机空间中的z坐标</span>
    o_AlbedoSpecular = i_AlbedoSpecular;
}
</pre>
<ul>
    <li>
        <p>
            没必要为了获得相机空间中的z坐标而把<code>view * <span class="type">vec4</span>(position, 1)</code>的结果保存到变量，透视投影矩阵与相机空间坐标相乘后得到的<span class="var">gl_Position.w</span>等于相机空间中的z坐标，解释在<a class="reference internal" href="Ch8-2%20%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%8F%AF%E8%A7%86%E5%8C%96.html#id2">前一节</a>。
        </p>
    </li>
</ul></section>
<section id="gbuffer-frag-shader">
<h3>GBuffer.frag.shader<a class="headerlink" href="#gbuffer-frag-shader" title="Permalink to this heading"></a></h3>
<pre class="code">
<span class="pragma">#version</span> 460
<span class="pragma">#pragma shader_stage</span>(fragment)

<span class="kw">layout</span>(location = 0) <span class="kw">in</span> <span class="type">vec4</span> i_NormalZ;
<span class="kw">layout</span>(location = 1) <span class="kw">in</span> <span class="type">vec4</span> i_AlbedoSpecular;
<span class="kw">layout</span>(location = 0) <span class="kw">out</span> <span class="type">vec4</span> o_NormalZ;
<span class="kw">layout</span>(location = 1) <span class="kw">out</span> <span class="type">vec4</span> o_AlbedoSpecular;

<span class="kw">void</span> <span class="fn">main</span>() {
    o_NormalZ = i_NormalZ;
    o_AlbedoSpecular = i_AlbedoSpecular;
}
</pre></section>
<section id="composition-vert-shader">
<h3>Composition.vert.shader<a class="headerlink" href="#composition-vert-shader" title="Permalink to this heading"></a></h3>
<p>
    绘制整个屏幕的范围。
    <br>
    输出NDC坐标的x和y，用于在片段着色器中求取片段对应的世界坐标系中的位置：
</p>
<pre class="code">
<span class="pragma">#version</span> 460
<span class="pragma">#pragma shader_stage</span>(vertex)

<span class="type">vec2</span> positions[4] = {
    { 0, 0 },
    { 0, 1 },
    { 1, 0 },
    { 1, 1 }
};

<span class="kw">layout</span>(location = 0) <span class="kw">out</span> <span class="type">vec2</span> o_Position;

<span class="kw">void</span> <span class="fn">main</span>() {
    o_Position = positions[gl_VertexIndex];
    gl_Position = <span class="type">vec4</span>(o_Position, 0, 1);
}
</pre></section>
<section id="composition-frag-shader">
<h3>Composition.frag.shader<a class="headerlink" href="#composition-frag-shader" title="Permalink to this heading"></a></h3>
<p>
    定义所有输入输出和可特化常量：
</p>
<pre class="code">
<span class="pragma">#version</span> 460
<span class="pragma">#pragma shader_stage</span>(fragment)

<span class="type">struct</span> light {
    <span class="type">vec3</span> position;
    <span class="type">vec3</span> color;
    <span class="kw">float</span> strength;
};
<span class="kw">layout</span>(constant_id = 0) <span class="kw">const uint</span> maxLightCount = 32;
<span class="kw">layout</span>(constant_id = 1) <span class="kw">const uint</span> shininess = 32;

<span class="kw">layout</span>(location = 0) <span class="kw">in</span> <span class="type">vec2</span> i_Position;
<span class="kw">layout</span>(location = 0) <span class="kw">out</span> <span class="type">vec4</span> o_Color;
<span class="kw">layout</span>(binding = 0) <span class="kw">uniform</span> descriptorConstants {
    <span class="type">mat4</span> proj;
    <span class="type">mat4</span> view;
    <span class="kw">int</span> lightCount;
    <span class="type">light</span> lights[maxLightCount];
};
<span class="kw">layout</span>(binding = 1, input_attachment_index = 0) <span class="kw">uniform</span> <span class="type">subpassInput</span> u_GBuffers[2];

<span class="kw">void</span> <span class="fn">main</span>() {
    <span class="cmt">/*待填充*/</span>
}
</pre>
<ul>
    <li>
        <p>
            涉及到的语法：<a class="reference internal" href="Ch4-1%20%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E7%BB%84.html#id13">输入附件的声明方式</a>、<a class="reference internal" href="Ch4-1%20%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E7%BB%84.html#id16">可特化常量的声明方式</a>。
        </p>
    </li>
</ul>
<p>
    如前文所言，我们需要使用相机空间下的z值、NDC坐标的x和y、投影矩阵、观察矩阵，来算出每个片段对应的世界坐标系中的位置。
    <br>
    首先用GLSL的内置函数<span class="fn">subpassLoad</span>(...)读取相应片段位置上G-buffer的数据，参数不言自明：
</p>
<pre class="code">
<span class="kw">void</span> <span class="fn">main</span>() {
    <span class="type">vec3</span> position;
    position.z = <span class="fn">subpassLoad</span>(u_GBuffers[0]).w;
    <span class="type">vec3</span> normal = <span class="fn">normalize</span>(<span class="fn">subpassLoad</span>(u_GBuffers[0]).xyz);
    <span class="type">vec3</span> albedo = <span class="fn">subpassLoad</span>(u_GBuffers[1]).xyz;
    <span class="kw">float</span> specular = <span class="fn">subpassLoad</span>(u_GBuffers[1]).w;
}
</pre>
<ul>
    <li>
        <p>
            用GLSL的内置函数<span class="fn">normalize</span>(...)将法向量标准化（即归一化，使其模长为1），以使之后的点乘能正确反映法向量与其他向量的夹角。
        </p>
    </li>
</ul>
<p>
    TODO 施工中
</p></section>
</section>
<section id="id5">
<h2>写入描述符<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h2>
<p>
    TODO 施工中
</p></section>
<section id="id6">
<h2>绘制<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h2>
<p>
    TODO 施工中
</p></section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Ch8-2%20%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%8F%AF%E8%A7%86%E5%8C%96.html" class="btn btn-neutral float-left" title="Ch8-2 深度测试和深度可视化" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="Ap1-1%20%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%BC%96%E8%AF%91GLSL.html" class="btn btn-neutral float-right" title="Ap1-1 运行期编译GLSL" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021-2024, Qiao YeCheng.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>